<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Calculating the Area of Multiple Intersecting Rectangles with Swift</title>

  <meta property="og:type" content="article" />
  <meta property="og:title" content="Calculating the Area of Multiple Intersecting Rectangles with Swift" />
  <meta property="og:url" content="https://twocentstudios.com/2016/08/16/calculating-the-area-of-multiple-intersecting-rectangles-with-swift/" />
  
    <meta property="og:article:published_time" content="2016-08-16T15:26:22-05:00" />
  
  
  
  <link href='https://fonts.googleapis.com/css2?family=Work+Sans:wght@300;350;400;600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://twocentstudios.com/2016/08/16/calculating-the-area-of-multiple-intersecting-rectangles-with-swift/">
  <link rel="alternate" type="application/rss+xml" title="twocentstudios" href="https://twocentstudios.com/feed.xml" />
</head>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NE82N02W8S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NE82N02W8S');
</script>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">twocentstudios</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/blog/">Blog</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/portfolio/">Portfolio</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Calculating the Area of Multiple Intersecting Rectangles with Swift</h1>
    <p class="post-meta">Aug 16, 2016</p>
  </header>

  <article class="post-content">
    <p>A piece of palate data I’m creating in my image to music generating app is the total ratio of the area faces in an image i.e. <code class="language-plaintext highlighter-rouge">totalAreaOfFaces / totalAreaOfPhoto</code>.</p>

<p>This turns out to be a lot like a classic programming algorithms interview question. Jump to <em>Implementation</em> if you want the TL;DR.</p>

<blockquote>
  <p>The code in this post targets iOS 9.3 and Swift 2.2.</p>
</blockquote>

<h2 id="naive-solution">Naive Solution</h2>

<p>At first, this seems like a trivial problem. Apple provides us with a facial recognition algorithm in the CoreImage framework. This algorithm takes a <code class="language-plaintext highlighter-rouge">CIImage</code> as input and returns <code class="language-plaintext highlighter-rouge">[CIFaceFeatures]</code> each of which contains a <code class="language-plaintext highlighter-rouge">bounds</code> property. Take the area of each bounds and add them together then divide by the area of the image and we’re done.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">/// WRONG - naive implementation</span>
<span class="kd">func</span> <span class="nf">ratioOfFaces</span><span class="p">(</span><span class="nv">image</span><span class="p">:</span> <span class="kt">CIImage</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CGFloat</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">context</span> <span class="o">=</span> <span class="kt">CIContext</span><span class="p">(</span><span class="nv">options</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">detector</span> <span class="o">=</span> <span class="kt">CIDetector</span><span class="p">(</span><span class="nv">ofType</span><span class="p">:</span> <span class="kt">CIDetectorTypeFace</span><span class="p">,</span> <span class="nv">context</span><span class="p">:</span> <span class="n">context</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">CIDetectorAccuracy</span><span class="p">:</span> <span class="kt">CIDetectorAccuracyHigh</span><span class="p">])</span>
    <span class="k">let</span> <span class="nv">features</span> <span class="o">=</span> <span class="n">detector</span><span class="o">.</span><span class="nf">featuresInImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">faceArea</span> <span class="o">=</span> <span class="n">features</span>
        <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">bounds</span> <span class="p">}</span>
        <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="nv">$0</span><span class="o">.</span><span class="n">height</span> <span class="p">}</span>
        <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">combine</span><span class="p">:</span> <span class="o">+</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">photoArea</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">extent</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">extent</span><span class="o">.</span><span class="n">height</span>
    <span class="k">let</span> <span class="nv">ratio</span> <span class="o">=</span> <span class="n">faceArea</span> <span class="o">/</span> <span class="n">photoArea</span>
    <span class="k">let</span> <span class="nv">clampedRatio</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clampedRatio</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The above implementation is fine if we assume that no face rects will intersect. Unfortunately, face rects <em>can</em> intersect. You can see this in the below image provided in the <a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_detect_faces/ci_detect_faces.html#//apple_ref/doc/uid/TP30001185-CH8-SW1">CoreImage documentation</a>.</p>

<div class="caption-wrapper"><img class="caption" src="/images/rectangles-apple_face_detection.png" width="" height="" alt="CoreImage Face Detection, note the overlapping rectangles (courtesy of Apple)." title="CoreImage Face Detection, note the overlapping rectangles (courtesy of Apple)." /><div class="caption-text">CoreImage Face Detection, note the overlapping rectangles (courtesy of Apple).</div></div>

<p>With the naive algorithm above, it’s possible for the output ratio to be greater than 1. For my purposes, it would be perfectly reasonable to use the above algorithm and clamp the output to 1, especially since an image that would produce a result greater than 1 would be very rare. There would have to be two or more faces that covered the entire area of the photo. However, I decided to see how complicated it would be to calculate the true combined area of an array of <em>n</em> overlapping rectangles.</p>

<h2 id="subtracting-the-intersections">Subtracting the Intersections</h2>

<p>Before Googling, my first attempt at an algorithm went like this:</p>

<ol>
  <li>Add up the areas of each rectangle in the input array.</li>
  <li>Exhaustively pair each rectangle in the input array with every other rectangle.</li>
  <li>Calculate the intersection rectangle between each pair.</li>
  <li>Subtract the intersecting rectangles from the total from (1).</li>
</ol>

<p>This algorithm works if you can guarantee that only two (or an even number) rectangles can intersect. However, when three (or an odd number) rectangles intersect, the intersecting rectangle must be added back. It follows the <a href="https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle">inclusion-exclusion principle</a>.</p>

<p>In visual form (thanks, <em>Numbers</em>):</p>

<div class="caption-wrapper"><img class="caption" src="/images/rectangles-two_rectangles.png" width="" height="" alt="Two overlapping rectangles." title="Two overlapping rectangles." /><div class="caption-text">Two overlapping rectangles.</div></div>

<p><code class="language-plaintext highlighter-rouge">3*3 + 3*3 - 3*1 = 15</code>
<code class="language-plaintext highlighter-rouge">green + red - (green &amp;&amp; red)</code></p>

<div class="caption-wrapper"><img class="caption" src="/images/rectangles-three_rectangles.png" width="" height="" alt="Three overlapping rectangles." title="Three overlapping rectangles." /><div class="caption-text">Three overlapping rectangles.</div></div>

<p><code class="language-plaintext highlighter-rouge">(3*3 + 3*3 + 3*3) - (3*1 + 2*1 + 2*1) + (1*1) = 21</code>
<code class="language-plaintext highlighter-rouge">(green + red + black) - (green &amp;&amp; red + green &amp;&amp; black + red &amp;&amp; black) + (green &amp;&amp; red &amp;&amp; black)</code></p>

<p>Notice the alternating + and -. Feel free to count them and see. If you don’t add back the <code class="language-plaintext highlighter-rouge">1*1</code> area covered by all three rectangles, your answer will be one short.</p>

<p>We’ve got to take it a step further.</p>

<h2 id="separating-in-one-dimension">Separating in One Dimension</h2>

<p>More Googling led me to <a href="http://codercareer.blogspot.com/2011/12/no-27-area-of-rectangles.html">this</a> algorithm. The pseudocode is as follows:</p>

<ol>
  <li>Determine and sort the unique X values (minX and maxX) for all rectangles in the array.</li>
  <li>Split all rectangles whose area falls within X values from (1).</li>
  <li>Merge all rectangles (on the Y axis) that have the same minX (and maxX).</li>
  <li>Calculate the area of each rectangle from (3) and add them up.</li>
</ol>

<p>Or in pictures:</p>

<div class="caption-wrapper"><img class="caption" src="/images/rectangles-algo1.png" width="" height="" alt="Step 0: Randomly generated overlapping rectangles." title="Step 0: Randomly generated overlapping rectangles." /><div class="caption-text">Step 0: Randomly generated overlapping rectangles.</div></div>

<div class="caption-wrapper"><img class="caption" src="/images/rectangles-algo2.png" width="" height="" alt="Step 1: Finding all the X coordinates." title="Step 1: Finding all the X coordinates." /><div class="caption-text">Step 1: Finding all the X coordinates.</div></div>

<div class="caption-wrapper"><img class="caption" src="/images/rectangles-algo3.png" width="" height="" alt="Step 2: Splitting all rects on X coordinates." title="Step 2: Splitting all rects on X coordinates." /><div class="caption-text">Step 2: Splitting all rects on X coordinates.</div></div>

<div class="caption-wrapper"><img class="caption" src="/images/rectangles-algo4.png" width="" height="" alt="Step 3: Combining rects on the Y boundaries." title="Step 3: Combining rects on the Y boundaries." /><div class="caption-text">Step 3: Combining rects on the Y boundaries.</div></div>

<h2 id="implementation">Implementation</h2>

<p>We have five discreet steps and two helper functions to implement.</p>

<blockquote>
  <p>Note: I’m pretty fast and loose with mixing functional and imperatives bits.</p>
</blockquote>

<h3 id="target-performance">Target Performance</h3>

<p>Before we start, it’s best to pick a performance target for our use case so we don’t fall into the trap of preoptimizing. My best guess is that the 95 percentile case will have less than 5 faces detected in a photo. It’s possible, but very unlikely we’d have anywhere near say 1000 faces. Therefore, we don’t have to optimize performance very much. I’m going to target the algorithm on 5 faces taking less than 0.05 seconds.</p>

<h3 id="high-level-function">High Level Function</h3>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">areaOfRects</span><span class="p">(</span><span class="nv">rects</span><span class="p">:</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">CGFloat</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">nonZeroRects</span> <span class="o">=</span> <span class="n">rects</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">area</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="k">let</span> <span class="nv">xDividers</span> <span class="o">=</span> <span class="nf">uniqueSortedXDividers</span><span class="p">(</span><span class="n">nonZeroRects</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">splitRects</span> <span class="o">=</span> <span class="nf">rectsSplitAtXDividers</span><span class="p">(</span><span class="n">nonZeroRects</span><span class="p">,</span> <span class="nv">xDividers</span><span class="p">:</span> <span class="n">xDividers</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">combinedRects</span> <span class="o">=</span> <span class="nf">combinedRectsOnY</span><span class="p">(</span><span class="n">splitRects</span><span class="p">,</span> <span class="nv">xDividers</span><span class="p">:</span> <span class="n">xDividers</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">area</span> <span class="o">=</span> <span class="n">combinedRects</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">rect</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CGFloat</span> <span class="k">in</span>
        <span class="k">return</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">rect</span><span class="o">.</span><span class="n">area</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">area</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The first step we have to add to the algorithm is to sanitize our input rect array for any zero area rectangles.</p>

<p>The middle three steps correspond to steps 1, 2, and 3 presented above.</p>

<p>The last step is to add up areas of all of our non intersecting rects to determine the final area.</p>

<h3 id="helper-functions">Helper Functions</h3>

<h4 id="area">area</h4>

<p>Area is pretty straightforward.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">CGRect</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">area</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="k">self</span><span class="o">.</span><span class="n">height</span>
    <span class="p">}</span>
<span class="p">}</span>    
</code></pre>
</div>

<h4 id="splitatx">splitAtX</h4>

<p>We’ll also need a function to split any rect at an X value.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">/// Split self into two rects at X. Otherwise, return self.</span>
<span class="kd">extension</span> <span class="kt">CGRect</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">splitAtX</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">CGFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="o">.</span><span class="n">minX</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="o">.</span><span class="n">maxX</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="k">self</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="nv">rect1</span> <span class="o">=</span> <span class="kt">CGRect</span><span class="p">(</span>
            <span class="nv">x</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">minX</span><span class="p">,</span>
            <span class="nv">y</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">minY</span><span class="p">,</span>
            <span class="nv">width</span><span class="p">:</span> <span class="n">x</span><span class="o">-</span><span class="k">self</span><span class="o">.</span><span class="n">minX</span><span class="p">,</span>
            <span class="nv">height</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">height</span>
        <span class="p">)</span>
        <span class="k">let</span> <span class="nv">rect2</span> <span class="o">=</span> <span class="kt">CGRect</span><span class="p">(</span>
            <span class="nv">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
            <span class="nv">y</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">minY</span><span class="p">,</span>
            <span class="nv">width</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">maxX</span><span class="o">-</span><span class="n">x</span><span class="p">,</span>
            <span class="nv">height</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">rect1</span><span class="p">,</span> <span class="n">rect2</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>    
</code></pre>
</div>

<p><code class="language-plaintext highlighter-rouge">CGRect</code> already has a function <code class="language-plaintext highlighter-rouge">CGRectDivide</code>, but since we have to do specific bounds checking anyway, I found it easier just to write my own.</p>

<h4 id="cgrectunion">CGRectUnion</h4>

<p><code class="language-plaintext highlighter-rouge">CGRectUnion(rect1, rect2)</code> finds the smallest rectangle that contains <code class="language-plaintext highlighter-rouge">rect1</code> and <code class="language-plaintext highlighter-rouge">rect2</code>.</p>

<div class="caption-wrapper"><img class="caption" src="/images/rectangles-union.png" width="" height="" alt="The union of two rectangles outlined in red." title="The union of two rectangles outlined in red." /><div class="caption-text">The union of two rectangles outlined in red.</div></div>

<h4 id="cgrectintersection--cgrectintersectsrect">CGRectIntersection &amp; CGRectIntersectsRect</h4>

<p><code class="language-plaintext highlighter-rouge">CGRectIntersection(rect1, rect2)</code> finds a rectangle shared by both <code class="language-plaintext highlighter-rouge">rect1</code> and <code class="language-plaintext highlighter-rouge">rect2</code> or <code class="language-plaintext highlighter-rouge">CGRectNull</code> if they do not intersect. It has a boolean cousin called <code class="language-plaintext highlighter-rouge">CGRectIntersectsRect</code>.</p>

<div class="caption-wrapper"><img class="caption" src="/images/rectangles-intersection.png" width="" height="" alt="The intersection of two rectangles filled in blue." title="The intersection of two rectangles filled in blue." /><div class="caption-text">The intersection of two rectangles filled in blue.</div></div>

<h3 id="uniquesortedxdividers">uniqueSortedXDividers</h3>

<p>Four transformations: take minX and maxX, flatten them back into one array, create a set to unique them, then sort min to max.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">/// Collect and unique all X coordinates.</span>
<span class="kd">func</span> <span class="nf">uniqueSortedXDividers</span><span class="p">(</span><span class="nv">rects</span><span class="p">:</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">CGFloat</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">xDividers</span> <span class="o">=</span> <span class="n">rects</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="p">[</span><span class="nv">$0</span><span class="o">.</span><span class="n">minX</span><span class="p">,</span> <span class="nv">$0</span><span class="o">.</span><span class="n">maxX</span><span class="p">]</span> <span class="p">}</span><span class="o">.</span><span class="nf">flatten</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">xDividersUniqueSorted</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="kt">Set</span><span class="p">(</span><span class="n">xDividers</span><span class="p">))</span><span class="o">.</span><span class="nf">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">xDividersUniqueSorted</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="rectssplitatxdividers">rectsSplitAtXDividers</h3>

<p>For the outer loop, loop through each X value. For the inner loop, loop through each rect, split it if necessary, and return it to the array.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">/// Split all rects at X coordinates.</span>
<span class="c1">/// Precondition: all rects must have non-zero area.</span>
<span class="kd">func</span> <span class="nf">rectsSplitAtXDividers</span><span class="p">(</span><span class="nv">rects</span><span class="p">:</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">],</span> <span class="nv">xDividers</span><span class="p">:</span> <span class="p">[</span><span class="kt">CGFloat</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">r</span> <span class="k">in</span> <span class="n">rects</span> <span class="p">{</span> <span class="nf">precondition</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">dividedRects</span><span class="p">:</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">]</span> <span class="o">=</span> <span class="n">rects</span>
    <span class="k">for</span> <span class="n">xDivider</span> <span class="k">in</span> <span class="n">xDividers</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">running</span><span class="p">:</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rect</span> <span class="k">in</span> <span class="n">dividedRects</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">dividedInputRects</span> <span class="o">=</span> <span class="n">rect</span><span class="o">.</span><span class="nf">splitAtX</span><span class="p">(</span><span class="n">xDivider</span><span class="p">)</span>
            <span class="n">running</span><span class="o">.</span><span class="nf">appendContentsOf</span><span class="p">(</span><span class="n">dividedInputRects</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">dividedRects</span> <span class="o">=</span> <span class="n">running</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dividedRects</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="combinerectsony">combineRectsOnY</h3>

<p>By splitting the rects on the X axis, we can now guarantee that:</p>

<ul>
  <li>no rects will overlap on the X axis.</li>
  <li>all rects with the same minX will also have the same width.</li>
</ul>

<p>Rects can still overlap on the Y axis though. We must now combine any rects that overlap.</p>

<p>Our outer loop is again on the X boundaries. The inner loop occurs only on the rects that lie on that X boundary, so we’re essentially touching each rect only once.</p>

<p>We have several conditions to handle for each X boundary.</p>

<ol>
  <li>There are no rects that lie on the X boundary.</li>
  <li>There is one rect that lies on the X boundary.</li>
  <li>There are two intersecting rects that lie on the X boundary.</li>
  <li>There are two non-intersecting rects that lie on the X boundary.</li>
  <li>With more than two rects, any combination of 3 and 4.</li>
</ol>

<p>Sorting rects by ascending Y value allows us to compare adjacent rects for intersection without skipping over any.</p>

<p>Within the <code class="language-plaintext highlighter-rouge">sortedRects</code> loop, we compare each rect to its preceding neighbor, combine them with <code class="language-plaintext highlighter-rouge">CGRectUnion</code> if they intersect, or add the previous rect to the output array if it does not intersect.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">/// For each set of rects at an X boundary,</span>
<span class="c1">/// combine the intersecting rects.</span>
<span class="c1">///</span>
<span class="c1">/// Precondition: all rects on the same X boundary must</span>
<span class="c1">/// be equal in width.</span>
<span class="kd">static</span> <span class="kd">func</span> <span class="nf">combinedRectsOnY</span><span class="p">(</span><span class="nv">rects</span><span class="p">:</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">],</span> <span class="nv">xDividers</span><span class="p">:</span> <span class="p">[</span><span class="kt">CGFloat</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">combinedRects</span><span class="p">:</span> <span class="p">[</span><span class="kt">CGRect</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">xDivider</span> <span class="k">in</span> <span class="n">xDividers</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">xFilteredRects</span> <span class="o">=</span> <span class="n">rects</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">minX</span> <span class="o">==</span> <span class="n">xDivider</span> <span class="p">}</span>
        <span class="k">let</span> <span class="nv">sortedRects</span> <span class="o">=</span> <span class="n">xFilteredRects</span><span class="o">.</span><span class="n">sort</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">minY</span> <span class="o">&lt;</span> <span class="nv">$1</span><span class="o">.</span><span class="n">minY</span> <span class="p">}</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">sortedRects</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">sortedRects</span><span class="o">.</span><span class="n">last</span> <span class="k">else</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
        <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="n">last</span> <span class="p">{</span>
            <span class="n">combinedRects</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="k">var</span> <span class="nv">prev</span> <span class="o">=</span> <span class="n">first</span>
        <span class="k">for</span> <span class="n">rect</span> <span class="k">in</span> <span class="n">sortedRects</span> <span class="p">{</span>
            <span class="nf">assert</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">prev</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="k">if</span> <span class="kt">CGRectIntersectsRect</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="kt">CGRectUnion</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">combinedRects</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">rect</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">combinedRects</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">combinedRects</span>
<span class="p">}</span>
</code></pre>
</div>

<blockquote>
  <p>An alternate implementation of this step could instead divide all rects on the Y boundaries (similar to the second step of our algorithm), then discard any rects that are the same.</p>
</blockquote>

<h2 id="using-our-function">Using Our Function</h2>

<p>Now that we can more accurately calculate the area of our face rectangles, here is the final implementation of our original problem.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">ratioOfFaces</span><span class="p">(</span><span class="nv">image</span><span class="p">:</span> <span class="kt">CIImage</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CGFloat</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">context</span> <span class="o">=</span> <span class="kt">CIContext</span><span class="p">(</span><span class="nv">options</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">detector</span> <span class="o">=</span> <span class="kt">CIDetector</span><span class="p">(</span><span class="nv">ofType</span><span class="p">:</span> <span class="kt">CIDetectorTypeFace</span><span class="p">,</span> <span class="nv">context</span><span class="p">:</span> <span class="n">context</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">CIDetectorAccuracy</span><span class="p">:</span> <span class="kt">CIDetectorAccuracyHigh</span><span class="p">])</span>
    <span class="k">let</span> <span class="nv">features</span> <span class="o">=</span> <span class="n">detector</span><span class="o">.</span><span class="nf">featuresInImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">faceRects</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">bounds</span> <span class="p">}</span>
    <span class="k">let</span> <span class="nv">faceArea</span> <span class="o">=</span> <span class="nf">areaOfRects</span><span class="p">(</span><span class="n">faceRects</span><span class="p">)</span> <span class="c1">// our algorithm</span>
    <span class="k">let</span> <span class="nv">photoArea</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">extent</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">extent</span><span class="o">.</span><span class="n">height</span>
    <span class="k">let</span> <span class="nv">ratio</span> <span class="o">=</span> <span class="n">faceArea</span> <span class="o">/</span> <span class="n">photoArea</span>
    <span class="k">return</span> <span class="n">ratio</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="other-algorithms">Other Algorithms</h2>

<p>From my cursory research, I found at least two other unique algorithms.</p>

<p>The first is the brute force approach: create a matrix the size of the union of all rectangles (initialized to 0), “color in” the area of rectangles in the matrix with a 1, then count the number of 1s.</p>

<p>The second recursively finds intersecting rectangles and applies the aforementioned inclusion-exclusion principle to add and subtract the intersecting areas.</p>

<p>See the Reddit link in the References section below if you’re interested in reading more about these.</p>

<h2 id="conclusion">Conclusion</h2>

<p>As an Electrical &amp; Computer Engineering major in college, I didn’t get as much algorithms practice as you Comp Sci-ers, so this was a fun little exercise for me.</p>

<p>@ me on Twitter <a href="https://twitter.com/twocentstudios">@twocentstudios</a> if you have ideas for a better algorithm!</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_detect_faces/ci_detect_faces.html#//apple_ref/doc/uid/TP30001185-CH8-SW1">Apple: Detecting Faces in an Image</a></li>
  <li><a href="http://codercareer.blogspot.com/2011/12/no-27-area-of-rectangles.html">Coder Career: Area of Rectangles</a></li>
  <li><a href="https://www.reddit.com/r/dailyprogrammer/comments/zaa0v/9032012_challenge_95_difficult_overlapping/">Reddit: Overlapping Rectangles Programming Challenge</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle">Inclusion-Exclusion Principle</a></li>
</ul>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">twocentstudios</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:chris@twocentstudios.com">chris@twocentstudios.com</a></li>
          
          <li>
            <a href="https://github.com/twocentstudios">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          

          <li>
            <a href="https://hackyderm.io/@twocentstudios">
              <span class="icon">
                <svg viewBox="0 0 24 24">
                  <path fill="#828282" d="M21.327 8.566c0-4.339-2.843-5.61-2.843-5.61-1.433-.658-3.894-.935-6.451-.956h-.063c-2.557.021-5.016.298-6.45.956 0 0-2.843 1.272-2.843 5.61 0 .993-.019 2.181.012 3.441.103 4.243.778 8.425 4.701 9.463 1.809.479 3.362.579 4.612.51 2.268-.126 3.541-.809 3.541-.809l-.075-1.646s-1.621.511-3.441.449c-1.804-.062-3.707-.194-3.999-2.409a4.523 4.523 0 0 1-.04-.621s1.77.433 4.014.536c1.372.063 2.658-.08 3.965-.236 2.506-.299 4.688-1.843 4.962-3.254.434-2.223.398-5.424.398-5.424zm-3.353 5.59h-2.081V9.057c0-1.075-.452-1.62-1.357-1.62-1 0-1.501.647-1.501 1.927v2.791h-2.069V9.364c0-1.28-.501-1.927-1.502-1.927-.905 0-1.357.546-1.357 1.62v5.099H6.026V8.903c0-1.074.273-1.927.823-2.558.566-.631 1.307-.955 2.228-.955 1.065 0 1.872.409 2.405 1.228l.518.869.519-.869c.533-.819 1.34-1.228 2.405-1.228.92 0 1.662.324 2.228.955.549.631.822 1.484.822 2.558v5.253z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>

          
          <li>
            <a href="https://twitter.com/twocentstudios">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          
        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
