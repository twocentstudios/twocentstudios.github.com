<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Testing Reducers and Interactors</title>

  <meta property="og:type" content="article" />
  <meta property="og:title" content="Testing Reducers and Interactors" />
  <meta property="og:url" content="https://twocentstudios.com/2018/02/18/testing-reducers-and-interactors/" />
  
    <meta property="og:article:published_time" content="2018-02-18T16:21:38-06:00" />
  
  
  
  <link href='https://fonts.googleapis.com/css2?family=Work+Sans:wght@300;350;400;600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://twocentstudios.com/2018/02/18/testing-reducers-and-interactors/">
  <link rel="alternate" type="application/rss+xml" title="twocentstudios" href="https://twocentstudios.com/feed.xml" />
</head>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NE82N02W8S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NE82N02W8S');
</script>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">twocentstudios</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/blog/">Blog</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/portfolio/">Portfolio</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Testing Reducers and Interactors</h1>
    <p class="post-meta">Feb 18, 2018</p>
  </header>

  <article class="post-content">
    <p>In this post we’ll discuss some techniques for testing the reducers and interactors we introduced in the previous <a href="/2017/08/02/transitioning-between-view-states-using-reducers/">reducers post</a> and <a href="/2017/11/05/interactors/">interactors post</a>.</p>

<p>The entire test suite can be viewed in the <a href="https://github.com/twocentstudios/ViewState">GitHub repo</a> for the example app. I’ll be excerpting a few illustrative cases in this post.</p>

<h2 id="goal">Goal</h2>

<p>One of the prescribed benefits of splitting our architecture into inert view models, single-state change reducers, long lived interactors, and a view layer is so that we could test each component individually.</p>

<p>Leaning on structs and enums as the input and output boundary of each component makes testing more straightforward; we need to create fewer mock classes to observe the behavior of the system.</p>

<p>Using a special <code class="language-plaintext highlighter-rouge">Scheduler</code> type to control the flow of time allows us to test asynchronous behavior without slowing down testing. It also allows us to mimic any sort of delays or operation ordering that would usually cause subtle, difficult to reproduce bugs in production.</p>

<h2 id="preview">Preview</h2>

<p>In the example app we had two systems: Profile and Posts. In this post we’ll only be showing examples from the Profile.</p>

<p>The reducer is trivial to test. It’s a pure function with two inputs, one output, and no side effects.</p>

<p>The interactor is a bit more complex. It will require a mock <code class="language-plaintext highlighter-rouge">Service</code> class for the data layer. It will require a special <code class="language-plaintext highlighter-rouge">Scheduler</code> type in order to control the flow of time.</p>

<h2 id="testing-the-reducer">Testing the reducer</h2>

<p>For the reducer, we’ll be testing each of the valid transitions specified by this diagram:</p>

<div class="caption-wrapper"><img class="caption" src="/images/transitioning_view_states-04.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>These will be more akin to <em>unit tests</em>.</p>

<h3 id="outline-of-profileinteractorreducertests">Outline of ProfileInteractorReducerTests</h3>

<p>Let’s start with an outline of the <code class="language-plaintext highlighter-rouge">XCTestCase</code> subclass we’ll be writing.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ProfileInteractorReducerTests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="kt">Reducer</span> <span class="o">=</span> <span class="kt">ProfileInteractor</span><span class="o">.</span><span class="kt">Reducer</span>
    
    <span class="k">let</span> <span class="nv">user</span> <span class="o">=</span> <span class="kt">Mocks</span><span class="o">.</span><span class="n">user</span>
    <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="kt">Mocks</span><span class="o">.</span><span class="n">error</span>
    
    <span class="kd">func</span> <span class="nf">testInitializedLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">testLoadingLoaded</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">testLoadingFailed</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">testFailedLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">testLoadedLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="mocks-and-helpers">Mocks and helpers</h3>

<p>Because we’ve namespaced our reducer under <code class="language-plaintext highlighter-rouge">ProfileInteractor</code> we’ll make a type alias to cut down on some boilerplate.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code>    <span class="kd">typealias</span> <span class="kt">Reducer</span> <span class="o">=</span> <span class="kt">ProfileInteractor</span><span class="o">.</span><span class="kt">Reducer</span>
</code></pre>
</div>

<p>We’ll also make some mock structs to cut down on boilerplate.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code>    <span class="k">let</span> <span class="nv">user</span> <span class="o">=</span> <span class="kt">Mocks</span><span class="o">.</span><span class="n">user</span>
    <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="kt">Mocks</span><span class="o">.</span><span class="n">error</span>
</code></pre>
</div>

<p>Where the <code class="language-plaintext highlighter-rouge">Mock</code> enum acts as a namespace:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Mocks</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">user</span> <span class="o">=</span> <span class="kt">User</span><span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                           <span class="nv">avatarURL</span><span class="p">:</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"https://en.gravatar.com/userimage/30721452/beb8f097031268cc19d5e6261603d419.jpeg"</span><span class="p">)</span><span class="o">!</span><span class="p">,</span>
                           <span class="nv">username</span><span class="p">:</span> <span class="s">"twocentstudios"</span><span class="p">,</span>
                           <span class="nv">friendsCount</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
                           <span class="nv">location</span><span class="p">:</span> <span class="s">"Chicago"</span><span class="p">,</span>
                           <span class="nv">website</span><span class="p">:</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"twocentstudios.com"</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
    
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="kt">NSError</span><span class="p">(</span><span class="nv">domain</span><span class="p">:</span> <span class="s">""</span><span class="p">,</span> <span class="nv">code</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">userInfo</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Finally, we’ll need to ensure we’ve implemented equatable for all of the structs we’ll use. This includes <code class="language-plaintext highlighter-rouge">ProfileViewModel</code>, <code class="language-plaintext highlighter-rouge">ProfileInteractor.Reducer.State</code>, <code class="language-plaintext highlighter-rouge">ProfileInteractor.Reducer.Command</code>, and <code class="language-plaintext highlighter-rouge">ProfileInteractor.Reducer.Effect</code>. Otherwise, we’d have no way to assert.</p>

<h3 id="writing-the-reducer-tests">Writing the reducer tests</h3>

<p>With the boilerplate out of the way, let’s write our first test.</p>

<p>Our first valid transition is a <code class="language-plaintext highlighter-rouge">ProfileViewModel</code> from <code class="language-plaintext highlighter-rouge">Initialized</code> to <code class="language-plaintext highlighter-rouge">Loading</code> state.</p>

<p>Remember that this state transition does not go directly from <code class="language-plaintext highlighter-rouge">Initialized</code> to <code class="language-plaintext highlighter-rouge">Loaded</code> and hit the network or perform other side effects. The reducer is a synchronous function. Its two outputs are 1. the state of the view model updated to <code class="language-plaintext highlighter-rouge">Loading</code> and 2. the <code class="language-plaintext highlighter-rouge">.load</code> <code class="language-plaintext highlighter-rouge">Effect</code> which will be used by the interactor to perform side effects.</p>

<blockquote>
  <p>Refer to the <a href="/2017/08/02/transitioning-between-view-states-using-reducers/">view state post</a> and <a href="/2017/08/02/transitioning-between-view-states-using-reducers/">reducers post</a> for more background.</p>
</blockquote>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ProfileInteractorReducerTests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">testInitializedLoad</span><span class="p">()</span> <span class="p">{</span>
    
        <span class="c1">// 1a. Create an initial `ProfileViewModel` and state containing it.</span>
        <span class="k">let</span> <span class="nv">initialViewModel</span> <span class="o">=</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="n">initialized</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">initialState</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">.</span><span class="kt">State</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">initialViewModel</span><span class="p">,</span> <span class="nv">effect</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="c1">// 1b. Specify the `Command` that will direct the state transition.</span>
        <span class="k">let</span> <span class="nv">command</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">.</span><span class="kt">Command</span><span class="o">.</span><span class="n">load</span>
        
        <span class="c1">// 2. Specify the target (expected) `ProfileViewModel`, `Effect`, and `State` combining the two.</span>
        <span class="k">let</span> <span class="nv">targetViewModel</span> <span class="o">=</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="n">loading</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">targetEffect</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">.</span><span class="kt">Effect</span><span class="o">.</span><span class="n">load</span>
        <span class="k">let</span> <span class="nv">targetState</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">.</span><span class="kt">State</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">targetViewModel</span><span class="p">,</span> <span class="nv">effect</span><span class="p">:</span> <span class="n">targetEffect</span><span class="p">)</span>
        
        <span class="c1">// 3. Call the function with (1) and (2) and store the result.</span>
        <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">initialState</span><span class="p">,</span> <span class="nv">command</span><span class="p">:</span> <span class="n">command</span><span class="p">)</span>
        
        <span class="c1">// 4. Assert the result from (4) is what we expect from (3).</span>
        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">targetState</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre>
</div>

<p>This is about as straightforward as you can get with a test.</p>

<ol>
  <li>Create some inert input data</li>
  <li>Create our expected output structs</li>
  <li>Call the function with the input data.</li>
  <li>Assert that our function output equals the output we expect.</li>
</ol>

<p>From here, we can copy paste this general structure and change the input and expected values.</p>

<blockquote>
  <p>There are probably better ways to automate writing and testing the reducer since it’s just a state machine. I’m open to ideas!</p>
</blockquote>

<p>Let’s show one more test for the transition from state <code class="language-plaintext highlighter-rouge">Loading</code> to <code class="language-plaintext highlighter-rouge">Failed</code>. Remember that the <code class="language-plaintext highlighter-rouge">Command</code> for this state transition comes as a result of the <code class="language-plaintext highlighter-rouge">Service</code> returning a value (presumably from the server), and all of that is handled by the interactor.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ProfileInteractorReducerTests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">testLoadingFailed</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">initialViewModel</span> <span class="o">=</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="n">loading</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">initialState</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">.</span><span class="kt">State</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">initialViewModel</span><span class="p">,</span> <span class="nv">effect</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        
        <span class="k">let</span> <span class="nv">command</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">.</span><span class="kt">Command</span><span class="o">.</span><span class="nf">failed</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        
        <span class="k">let</span> <span class="nv">targetViewModel</span> <span class="o">=</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="nf">failed</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
        <span class="k">let</span> <span class="nv">targetEffect</span><span class="p">:</span> <span class="kt">Reducer</span><span class="o">.</span><span class="kt">Effect</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
        <span class="k">let</span> <span class="nv">targetState</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">.</span><span class="kt">State</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">targetViewModel</span><span class="p">,</span> <span class="nv">effect</span><span class="p">:</span> <span class="n">targetEffect</span><span class="p">)</span>
        
        <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">initialState</span><span class="p">,</span> <span class="nv">command</span><span class="p">:</span> <span class="n">command</span><span class="p">)</span>
        
        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">targetState</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The same sequence of statements is used, but we’re comparing different inputs and outputs.</p>

<h3 id="which-transitions-to-test">Which transitions to test?</h3>

<p>In the <a href="">source</a>, I’m only testing valid transitions. However, we could also test that invalid transitions are handled in a deterministic way. The rigor of your test coverage is up to you.</p>

<p>In the most rigorous implementation of a reducer, you could add an <code class="language-plaintext highlighter-rouge">Effect</code> for invalid transitions. Upstream, in the interactor, you could use that <code class="language-plaintext highlighter-rouge">Effect</code> to log an error to an external service. This would keep your reducer completely deterministic and side-effect free.</p>

<h2 id="testing-the-interactor">Testing the interactor</h2>

<p>For the interactor, we’ll be testing end-to-end transitions. We could also mirror our reducer tests, but as you’ll see, it makes more sense to lean towards <em>integration tests</em> here since we can now fully exercise the asynchronous nature of the interactor.</p>

<blockquote>
  <p>I’ll talk a little bit about integration testing with the interactor vs UI testing with UIKit and Xcode a bit later.</p>
</blockquote>

<h3 id="outline-of-profileinteractortests">Outline of ProfileInteractorTests</h3>

<p>Going back to our state transition diagram:</p>

<div class="caption-wrapper"><img class="caption" src="/images/transitioning_view_states-04.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>Let’s outline <code class="language-plaintext highlighter-rouge">ProfileInteractorTests</code>.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ProfileInteractorTests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="kt">Command</span> <span class="o">=</span> <span class="kt">ProfileInteractor</span><span class="o">.</span><span class="kt">Command</span>
    <span class="kd">typealias</span> <span class="kt">Effect</span> <span class="o">=</span> <span class="kt">ProfileInteractor</span><span class="o">.</span><span class="kt">Effect</span>
    
    <span class="k">let</span> <span class="nv">user</span> <span class="o">=</span> <span class="kt">Mocks</span><span class="o">.</span><span class="n">user</span>
    <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="kt">Mocks</span><span class="o">.</span><span class="n">error</span>
    
    <span class="c1">// Initialized</span>
    <span class="kd">func</span> <span class="nf">testInitialState</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="c1">// Initialized -&gt; Load -&gt; Loaded</span>
    <span class="kd">func</span> <span class="nf">testInitializedLoadSuccess</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>

    <span class="c1">// Initialized -&gt; Load -&gt; Failed    </span>
    <span class="kd">func</span> <span class="nf">testInitializedLoadFailure</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="c1">// Failed -&gt; Load -&gt; Success</span>
    <span class="kd">func</span> <span class="nf">testFailureThenSuccess</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We’ve decided on four cases:</p>

<ol>
  <li><strong>Initialized</strong> - ensure our system starts in a known state.</li>
  <li><strong>Initialized -&gt; Load -&gt; Loaded</strong> - expected success case.</li>
  <li><strong>Initialized -&gt; Load -&gt; Failed</strong> - failure case.</li>
  <li><strong>Failed -&gt; Load -&gt; Success</strong> - retry failure to success case.</li>
</ol>

<h3 id="mocks-and-helpers-1">Mocks and helpers</h3>

<p>Like the reducer tests above, we’ll use some <code class="language-plaintext highlighter-rouge">typealias</code>es and mocks to cut down on boilerplate.</p>

<p>We’ll also need to add two new mock classes that our interactor(s) have as dependencies.</p>

<h4 id="profileservice">ProfileService</h4>

<p><code class="language-plaintext highlighter-rouge">Mock.ProfileService</code> should conform to <code class="language-plaintext highlighter-rouge">ProfileServiceType</code>:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">ProfileServiceType</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">readProfile</span><span class="p">(</span><span class="nv">userId</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">SignalProducer</span><span class="o">&lt;</span><span class="kt">User</span><span class="p">,</span> <span class="kt">NSError</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Our mock should return a valid user or an error depending on what we want to test.</p>

<p>The simplest version of this mock can just mirror whatever <code class="language-plaintext highlighter-rouge">Result</code> we set.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Mocks</span> <span class="p">{</span>
    <span class="kd">final</span> <span class="kd">class</span> <span class="kt">ProfileService</span><span class="p">:</span> <span class="kt">ProfileServiceType</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">User</span><span class="p">,</span> <span class="kt">NSError</span><span class="o">&gt;!</span>
        
        <span class="kd">func</span> <span class="nf">readProfile</span><span class="p">(</span><span class="nv">userId</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">SignalProducer</span><span class="o">&lt;</span><span class="kt">User</span><span class="p">,</span> <span class="kt">NSError</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kt">SignalProducer</span><span class="p">(</span><span class="nv">result</span><span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>But I made some helpers so the test code looks a little cleaner.</p>

<h4 id="testschedulercontext">TestSchedulerContext</h4>

<p>The interface for the interactor accepts a <code class="language-plaintext highlighter-rouge">SchedulerContextType</code>. This requires a more detailed explanation, but for now I’ll explain the basics.</p>

<p><code class="language-plaintext highlighter-rouge">SchedulerContextType</code> asks for three distinct schedulers:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">state</code> to update state by running the synchronous reducer function.</li>
  <li><code class="language-plaintext highlighter-rouge">work</code> to dispatch asynchronous work like network requests.</li>
  <li><code class="language-plaintext highlighter-rouge">output</code> to set the <code class="language-plaintext highlighter-rouge">viewModel</code> and <code class="language-plaintext highlighter-rouge">effect</code> variables.</li>
</ul>

<p>This will allow us to manipulate the flow of time and observe/assert the state of the system at critical points.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">TestSchedulerContext</span><span class="p">:</span> <span class="kt">SchedulerContextType</span> <span class="p">{</span>
    
    <span class="c1">// ...</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">TestScheduler</span> <span class="o">=</span> <span class="kt">TestScheduler</span><span class="p">(),</span> <span class="nv">work</span><span class="p">:</span> <span class="kt">TestScheduler</span> <span class="o">=</span> <span class="kt">TestScheduler</span><span class="p">(),</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">TestScheduler</span> <span class="o">=</span> <span class="kt">TestScheduler</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">testState</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">self</span><span class="o">.</span><span class="n">testWork</span> <span class="o">=</span> <span class="n">work</span>
        <span class="k">self</span><span class="o">.</span><span class="n">testOutput</span> <span class="o">=</span> <span class="n">output</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">nextOutput</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">testState</span><span class="o">.</span><span class="nf">advance</span><span class="p">()</span>
        <span class="n">testOutput</span><span class="o">.</span><span class="nf">advance</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">doWork</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">testWork</span><span class="o">.</span><span class="nf">advance</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>I’ve added two helper functions to formalize how the schedulers should be advanced: <code class="language-plaintext highlighter-rouge">nextOutput</code> which accepts input, computes a new state, and delivers output; and <code class="language-plaintext highlighter-rouge">doWork</code> which simulates the service layer returning a new result.</p>

<h4 id="testobserver">TestObserver</h4>

<p><code class="language-plaintext highlighter-rouge">TestObserver</code> is a helper class specifically for testing the output of <code class="language-plaintext highlighter-rouge">ReactiveSwift</code> signals. This was originally written by the Kickstarter team (their source <a href="https://github.com/kickstarter/Kickstarter-ReactiveExtensions/blob/15631b40c437d18db4187d9b8ad117115775ea3f/ReactiveExtensions/test-helpers/TestObserver.swift">here</a>).</p>

<p>The header comments explain its purpose:</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>A `TestObserver` is a wrapper around an `Observer` that saves all events 
to an internal array so that assertions can be made on a signal's behavior. 
To use, just create an instance of `TestObserver` that matches the type of 
signal/producer you are testing, and observer/start your signal by feeding 
it the wrapped observer. For example,

 let test = TestObserver&lt;Int, NoError&gt;()
 mySignal.observer(test.observer)
 
 // ... later ...
 
 test.assertValues([1, 2, 3])
</code></pre>
</div>

<h3 id="writing-the-interactor-tests">Writing the interactor tests</h3>

<p>Let’s start with the first test: ensuring our interactor has the expected initial state.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ProfileInteractorTests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    
    <span class="c1">// Initialized</span>
    <span class="kd">func</span> <span class="nf">testInitialState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">schedulerContext</span> <span class="o">=</span> <span class="kt">TestSchedulerContext</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">service</span> <span class="o">=</span> <span class="kt">Mocks</span><span class="o">.</span><span class="kt">ProfileService</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
        
        <span class="c1">// 1. Create the interactor with dependencies.</span>
        <span class="k">let</span> <span class="nv">interactor</span> <span class="o">=</span> <span class="kt">ProfileInteractor</span><span class="p">(</span><span class="nv">userId</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nv">service</span><span class="p">:</span> <span class="n">service</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">schedulerContext</span><span class="p">)</span>
        
        <span class="c1">// 2. Create the expected view model.</span>
        <span class="k">let</span> <span class="nv">targetViewModel</span> <span class="o">=</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="n">initialized</span><span class="p">)</span>
        
        <span class="c1">// 3. Probe the result view model stored in the property.</span>
        <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">interactor</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="n">value</span>
        
        <span class="c1">// 4. Assert equality.</span>
        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">targetViewModel</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<blockquote>
  <p>Note that we don’t need to run the output scheduler since the interactor’s <code class="language-plaintext highlighter-rouge">viewModel.value</code> is set on whatever scheduler <code class="language-plaintext highlighter-rouge">init</code> is called on.</p>
</blockquote>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ProfileInteractorTests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    
    <span class="c1">// Initialized -&gt; Load -&gt; Loaded</span>
    <span class="kd">func</span> <span class="nf">testInitializedLoadSuccess</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">schedulerContext</span> <span class="o">=</span> <span class="kt">TestSchedulerContext</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">service</span> <span class="o">=</span> <span class="kt">Mocks</span><span class="o">.</span><span class="kt">ProfileService</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
        
        <span class="c1">// 1. Create the interactor with dependencies.</span>
        <span class="k">let</span> <span class="nv">interactor</span> <span class="o">=</span> <span class="kt">ProfileInteractor</span><span class="p">(</span><span class="nv">userId</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nv">service</span><span class="p">:</span> <span class="n">service</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">schedulerContext</span><span class="p">)</span>
        
        <span class="c1">// 2. Create a TestObserver for the `Effect` output.</span>
        <span class="k">let</span> <span class="nv">effect</span><span class="p">:</span> <span class="kt">TestObserver</span><span class="o">&lt;</span><span class="kt">Effect</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">TestObserver</span><span class="p">()</span>
        <span class="n">interactor</span><span class="o">.</span><span class="n">effect</span><span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="n">effect</span><span class="o">.</span><span class="n">observer</span><span class="p">)</span>
        
        <span class="c1">// 3. Create the `Command` to test.</span>
        <span class="k">let</span> <span class="nv">command</span> <span class="o">=</span> <span class="kt">Command</span><span class="o">.</span><span class="n">load</span>
        
        <span class="c1">// 4. Create the two expected view model states.</span>
        <span class="k">let</span> <span class="nv">loadingViewModel</span> <span class="o">=</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="n">loading</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">loadedViewModel</span> <span class="o">=</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="nf">loaded</span><span class="p">(</span><span class="n">user</span><span class="p">))</span>
        
        <span class="c1">// 5. Send `Command.Load` to simulate the load start.</span>
        <span class="n">interactor</span><span class="o">.</span><span class="n">commandSink</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">command</span><span class="p">)</span>
        
        <span class="c1">// 6. Tell the `schedulerContext` to run one output cycle.</span>
        <span class="n">schedulerContext</span><span class="o">.</span><span class="nf">nextOutput</span><span class="p">()</span>
        
        <span class="c1">// 7. Probe the result view model stored in the property.</span>
        <span class="k">let</span> <span class="nv">loadingResult</span> <span class="o">=</span> <span class="n">interactor</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="n">value</span>
        
        <span class="c1">// 8. Assert that the view model is now in `loading` state.</span>
        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">loadingViewModel</span><span class="p">,</span> <span class="n">loadingResult</span><span class="p">)</span>
        
        <span class="c1">// 9. Assert that there were no other side-effects produced.</span>
        <span class="n">effect</span><span class="o">.</span><span class="nf">assertValueCount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">effect</span><span class="o">.</span><span class="nf">assertDidNotComplete</span><span class="p">()</span>
        
        <span class="c1">// 10. Tell the `schedulerContext` to run one service cycle and one output cycle.</span>
        <span class="n">schedulerContext</span><span class="o">.</span><span class="nf">doWork</span><span class="p">()</span>
        <span class="n">schedulerContext</span><span class="o">.</span><span class="nf">nextOutput</span><span class="p">()</span>
        
        <span class="c1">// 11. Probe the result view model stored in the property again.</span>
        <span class="k">let</span> <span class="nv">loadedResult</span> <span class="o">=</span> <span class="n">interactor</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="n">value</span>
        
        <span class="c1">// 12. Assert that the view model is now in `loading` state.</span>
        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">loadedViewModel</span><span class="p">,</span> <span class="n">loadedResult</span><span class="p">)</span>

        <span class="c1">// 13. Assert that there were no other side-effects produced.</span>
        <span class="n">effect</span><span class="o">.</span><span class="nf">assertValueCount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">effect</span><span class="o">.</span><span class="nf">assertDidNotComplete</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>A couple things to note:</p>

<ul>
  <li>[2][9][13] Because our <code class="language-plaintext highlighter-rouge">interactor.effect</code> is a stateless <code class="language-plaintext highlighter-rouge">Signal</code>, we need to use <code class="language-plaintext highlighter-rouge">TestObserver</code> to temporary capture its values (or lack there of) to assert.</li>
  <li>[6][10] We have to call functions on <code class="language-plaintext highlighter-rouge">schedulerContext</code> to artificially advance time.</li>
</ul>

<p>The interactor tests are more like integration tests. There’s a lot more internal behavior handled by the interactor in order to produce the <code class="language-plaintext highlighter-rouge">viewModel</code> and <code class="language-plaintext highlighter-rouge">effect</code> outputs. However, we get much more control and granularity as opposed to UI testing.</p>

<p>See <a href="">the source</a> for the other two cases I decided to test. They’re very similar.</p>

<h2 id="ui-testing">UI testing</h2>

<p>Judging from the types of testing I’ve decided to focus on in this post, you can probably glean some of my views on testing.</p>

<p>My past team experience focused on using manual pre-release testing to discover UI bugs. We did no automated UI testing at all. The biggest reason was that almost every screen in our app changed in a non-trivial way at least once a month. Maintaining expectation images and UI automation testing would have required resources we didn’t have.</p>

<p>In this post, I specifically target my tests in code outside of <code class="language-plaintext highlighter-rouge">UIKit</code>. The architecture itself from the last four posts is designed to push code as far as reasonably possible outside of <code class="language-plaintext highlighter-rouge">UIKit</code>. <code class="language-plaintext highlighter-rouge">UIKit</code> simply introduces far too much state and far too many side-effects into a system for me to feel confident that my tests are useful.</p>

<p>Although there has been lots of progress made both by Apple and in open source in making UI testing more useful and feasible, I still consider manual testing to be more resource efficient than writing and maintaining a suite of UI tests especially for the kinds of apps I currently work on.</p>

<p>I would love to have my mind changed though. I hope UI testing becomes more mainstream as tooling improves. And certainly if you have the design stability and the resources, automate as much testing as you can!</p>

<h2 id="summary">Summary</h2>

<p>In this post we looked at writing tests for our reducer and interactor.</p>

<p>The reducer tests were trivial unit tests. The interactor tests are more involved, but give us a lot of control to test the limited interface of the interactor.</p>

<p>Although on the surface scheduler contexts seem to complicate our code a bit, I think it’s really useful to have both control and understanding of how and when code is being run. Notice that we didn’t have to wait for any expectations. The test code follows a linear and logical progression.</p>

<p>A few questions I’d like to ponder for the future:</p>

<ul>
  <li>Since our reducer is a straightforward state machine, are there better ways to automate testing?</li>
  <li>Is there a way we can eliminate at least one of the three scheduler context types? Perhaps the <code class="language-plaintext highlighter-rouge">state</code> scheduler can use the <code class="language-plaintext highlighter-rouge">output</code> scheduler instead?</li>
</ul>

<h2 id="further-reading">Further reading</h2>

<ul>
  <li><a href="https://talk.objc.io/episodes/S01E53-test-driven-reactive-programming-at-kickstarer">objc.io: Test-Driven Reactive Programming</a></li>
  <li><a href="http://adamborek.com/rxtests-rxactionsheet/">RxTest – How to test the Observable in Swift</a></li>
</ul>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">twocentstudios</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:chris@twocentstudios.com">chris@twocentstudios.com</a></li>
          
          <li>
            <a href="https://github.com/twocentstudios">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          

          <li>
            <a href="https://hackyderm.io/@twocentstudios">
              <span class="icon">
                <svg viewBox="0 0 24 24">
                  <path fill="#828282" d="M21.327 8.566c0-4.339-2.843-5.61-2.843-5.61-1.433-.658-3.894-.935-6.451-.956h-.063c-2.557.021-5.016.298-6.45.956 0 0-2.843 1.272-2.843 5.61 0 .993-.019 2.181.012 3.441.103 4.243.778 8.425 4.701 9.463 1.809.479 3.362.579 4.612.51 2.268-.126 3.541-.809 3.541-.809l-.075-1.646s-1.621.511-3.441.449c-1.804-.062-3.707-.194-3.999-2.409a4.523 4.523 0 0 1-.04-.621s1.77.433 4.014.536c1.372.063 2.658-.08 3.965-.236 2.506-.299 4.688-1.843 4.962-3.254.434-2.223.398-5.424.398-5.424zm-3.353 5.59h-2.081V9.057c0-1.075-.452-1.62-1.357-1.62-1 0-1.501.647-1.501 1.927v2.791h-2.069V9.364c0-1.28-.501-1.927-1.502-1.927-.905 0-1.357.546-1.357 1.62v5.099H6.026V8.903c0-1.074.273-1.927.823-2.558.566-.631 1.307-.955 2.228-.955 1.065 0 1.872.409 2.405 1.228l.518.869.519-.869c.533-.819 1.34-1.228 2.405-1.228.92 0 1.662.324 2.228.955.549.631.822 1.484.822 2.558v5.253z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>

          
          <li>
            <a href="https://twitter.com/twocentstudios">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          
        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
