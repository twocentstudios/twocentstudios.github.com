<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Simple AJAX Comments with Rails</title>

  <meta property="og:type" content="article" />
  <meta property="og:title" content="Simple AJAX Comments with Rails" />
  <meta property="og:url" content="https://twocentstudios.com/2012/11/15/simple-ajax-comments-with-rails/" />
  
    <meta property="og:article:published_time" content="2012-11-15T09:50:00-06:00" />
  
  
  
  <link href='https://fonts.googleapis.com/css2?family=Work+Sans:wght@300;350;400;600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://twocentstudios.com/2012/11/15/simple-ajax-comments-with-rails/">
  <link rel="alternate" type="application/rss+xml" title="twocentstudios" href="https://twocentstudios.com/feed.xml" />
</head>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NE82N02W8S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NE82N02W8S');
</script>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">twocentstudios</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/blog/">Blog</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/portfolio/">Portfolio</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Simple AJAX Comments with Rails</h1>
    <p class="post-meta">Nov 15, 2012</p>
  </header>

  <article class="post-content">
    <blockquote>
  <p>Update 2014-06-08: This post is over two years old now. Although I’ve heard the below walkthrough works  mostly as expected, I’ve been away from Rails too long to know the ins and outs of the current version of Rails and all the gems used. So a word of warning: I can’t guarantee all of the below will work line-for-line anymore. Feel free to ping me on Twitter if you find any changes.</p>
</blockquote>

<p>I’ve been working on and off with Rails for a few years now, but when I started I had little HTML/CSS/JS knowledge from which to build. Most of my web experience I learned along the way in the context of Rails.</p>

<p>HTML and CSS were much easier to build familiarity with than JavaScript. I always found more time-tested best practices concerning HTML and CSS than I did with JS/AJAX. AJAX with Rails techniques seemed to have changed significantly between releases of Rails major (and even minor) versions.</p>

<p>I am by no means an expert, but my goal with this post is to walk beginners through a working technique for vanilla AJAX comments on resources based on Rails 3.2.x.</p>

<h2 id="what-were-making">What we’re making</h2>

<p>Our goal is to make a comment form that we can attach to any resource in our Rails app. It will look something like this:</p>

<div class="caption-wrapper"><img class="caption" src="/images/rails-comments-ss-1.png" width="" height="" alt="Our goal" title="Our goal" /><div class="caption-text">Our goal</div></div>

<p>The layout is pretty standard. A create form sits on top of a list of comments (newest first).</p>

<p>Our example resource throughout this post is an “Event”. We’ll only discuss it in terms of being an example generic resource with comments that belong to it.</p>

<h3 id="create">Create</h3>

<p>When a logged in user enters a comment and clicks “Create Comment”, the browser sends a message back to the server with the comment body, the resource name, and resource id. Once the server processes the message, it will send the comment body rendered in HTML in the same partial as the other comments were rendered with.</p>

<p>In the meantime, on the client side, we’ll be doing some basic jQuery effects to let the user know their comment is being processed. We’ll disable the textarea and submit button so they don’t accidentally submit the same comment twice.</p>

<p>Once the server returns our new HTML, we’ll reenable the form controls, clear the text from the textarea, and then add the new HTML to the top of the comment list.</p>

<p>To keep it simple for now, we won’t be handling the error cases in significant detail.</p>

<h4 id="processing-order">Processing order</h4>

<ul>
  <li>route: GET /event/1</li>
  <li>controller: events#show</li>
  <li>view: events/show.html.haml</li>
  <li>partial: comments/_form.html.haml</li>
  <li>partial: comments/_comment.html.haml</li>
  <li>user: add comment body and click create</li>
  <li>js: comments.js.coffee -&gt; ajax:beforeSend</li>
  <li>route: POST /comments</li>
  <li>controller: comments#create</li>
  <li>partial: comments/_comment.html.haml</li>
  <li>js: comments.js.coffee -&gt; ajax:success</li>
</ul>

<p>We’ll touch on each of these steps, but not necessarily in that order.</p>

<h3 id="delete">Delete</h3>

<p>We’ll also allow users to delete comments (eventually only comments they’ve created!). When they click the ‘x’ next to the comment, we’ll prompt them with a standard confirmation. If they answer yes, we’ll then send the comment id to the server.</p>

<p>On the browser side, we’ll immediately dim the comment to half opacity to let the user know we’re trying to delete the comment. Once we receive a response indicating the comment has been removed from the database, we’ll then hide the comment in their browser the rest of the way.</p>

<p>There are a few error conditions we should handle here as well, but we won’t look at those in this post.</p>

<h4 id="processing-order-1">Processing order</h4>

<ul>
  <li>route: GET /event/1</li>
  <li>controller: events#show</li>
  <li>view: events/show.html.haml</li>
  <li>partial: comments/_form.html.haml</li>
  <li>partial: comments/_comment.html.haml</li>
  <li>user: click “x” next to comment</li>
  <li>user: click “yes” to confirm</li>
  <li>js: comments.js.coffee -&gt; ajax:beforeSend</li>
  <li>route: DELETE /comments/1</li>
  <li>controller: comments#destroy</li>
  <li>partial: comment.json</li>
  <li>js: comments.js.coffee -&gt; ajax:success</li>
</ul>

<p>The first half is the same as we’ll see for comment creation, so we’ll focus on the last half mostly in that order.</p>

<h2 id="where-to-start">Where to start?</h2>

<p>First place to start is getting our backend comment system in place. We’ll be using the <a href="https://github.com/elight/acts_as_commentable_with_threading">acts_as_commentable_with_threading</a> gem (although we won’t be using the threading right away).</p>

<p>The instructions for setting this up are pretty simple. I’m just using ActiveRecord and SQLite right now.</p>

<ul>
  <li>Put the gem in your bundle <code class="language-plaintext highlighter-rouge">gem acts_as_commentable_with_threading</code>.</li>
  <li>Run <code class="language-plaintext highlighter-rouge">bundle install</code>.</li>
  <li>Run the migrations <code class="language-plaintext highlighter-rouge">rails g acts_as_commentable_with_threading_migration</code>.</li>
  <li>Run <code class="language-plaintext highlighter-rouge">rake db:migrate</code>.</li>
  <li>
    <p>Add <code class="language-plaintext highlighter-rouge">acts_as_commentable</code> to the <code class="language-plaintext highlighter-rouge">Event</code> model class (and any other model you want to have comments).</p>

    <div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>  # event.rb
  class Event &lt; ActiveRecord::Base
		acts_as_commentable
  end		
</code></pre>
    </div>
  </li>
</ul>

<p>This post is supposed to be more about AJAX than Rails associations, but it’s worth mentioning that acts_as_commentable uses a <a href="http://guides.rubyonrails.org/association_basics.html#polymorphic-associations">polymorphic association</a>. This means that any of your models can reference the same kind of comment model object, and we don’t have to have a separate table in our database for an <code class="language-plaintext highlighter-rouge">EventComment</code> or a <code class="language-plaintext highlighter-rouge">VideoComment</code> for example. Each comment record keeps track of what type of object its parent is, which will be important later since we need to know information about the parent in order to create a comment.</p>

<h2 id="routes">Routes</h2>

<p>Next we’ll set up our routes just to get that out of the way. We’re going to let the <code class="language-plaintext highlighter-rouge">CommentsController</code> handle creation and deletion of comments, so the routes should point there.</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	# routes.rb
	resources :comments, :only =&gt; [:create, :destroy]
</code></pre>
</div>

<p>This will give us two methods from the following urls (from <code class="language-plaintext highlighter-rouge">rake routes</code>).</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	$ rake routes
	comments 	POST 		/comments(.:format) 	comments#create
	comment 	DELETE 	/comments/:id(.:format) 	comments#destroy
</code></pre>
</div>

<p>This is going to give us a <code class="language-plaintext highlighter-rouge">commments_path</code> helper and <code class="language-plaintext highlighter-rouge">comment_path(:id)</code> helper to complete our POST and DELETE requests,  respectively. It will forward requests to those URLs to the <code class="language-plaintext highlighter-rouge">CommentsController</code>’s <code class="language-plaintext highlighter-rouge">create</code> and <code class="language-plaintext highlighter-rouge">destroy</code> methods. The create method has no parameters in the URL string. The destroy method takes the comment’s <code class="language-plaintext highlighter-rouge">id</code> as the single parameter of the URL string. Like we mentioned earlier, in order to create the comment, we’ll need a few more parameters. We’ll talk more about that when we get to the form.</p>

<h3 id="alternate-implementation">Alternate implementation</h3>

<p>Aside: An alternate implementation worth mentioning is to include comments as a <a href="http://guides.rubyonrails.org/routing.html#nested-resources">nested resource</a> beneath each resource that has them. It would look something like this:</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	# routes.rb - alternate
	resources :events
		resources :comments, :only =&gt; [:create, :destroy]
	end
	
	resources :videos
		resources :comments, :only =&gt; [:create, :destroy]
	end
</code></pre>
</div>

<p>This works fine if your resources are all siblings. In my case, I have <code class="language-plaintext highlighter-rouge">Video</code> nested within <code class="language-plaintext highlighter-rouge">Event</code> already. It gets pretty hairy pretty quickly and gives you (unnecessarily) complicated routes and URLs. In this case, we’ll go with the other implementation that includes the necessary data about the comment’s parent in the HTTP POST data rather than the URL string.</p>

<p>Again, it works either way so always tailor your implementation based on your particular situation.</p>

<h2 id="showhtmlhaml">show.html.haml</h2>

<p>Now that we’ve got the bridge between the view and the controller built (the route), we’ll tackle the show view template.</p>

<p>Our goal is to be able put the comment “block” (the add new form and the list of previously created comments) anywhere. In this example, we’ll stick it in the <code class="language-plaintext highlighter-rouge">show</code> view of the <code class="language-plaintext highlighter-rouge">EventsController</code>.</p>

<p>(Sidebar: I use <a href="http://www.haml.info">Haml</a> and <a href="https://github.com/plataformatec/simple_form">simple form</a>, sorry in advance to users of other templates. Hopefully you can still follow along.)</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	/ show.html.haml
	.event
		%h1= @event.name
	.comments
		%h2 Comments
		= render :partial =&gt; 'comments/form', :locals =&gt; { :comment =&gt; @new_comment }
		= render :partial =&gt; 'comments/comment', :collection =&gt; @comments, :as =&gt; :comment
</code></pre>
</div>

<p>As you can see, our show template expects 3 different instance variables from the <code class="language-plaintext highlighter-rouge">EventsController</code>.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@event</code>: the unique <code class="language-plaintext highlighter-rouge">Event</code> object we’re showing.</li>
  <li><code class="language-plaintext highlighter-rouge">@new_comment</code>: a new <code class="language-plaintext highlighter-rouge">Comment</code> object that acts as our framework for building out the comment form. It exists only in Rails for now and has not been created in the database yet.</li>
  <li><code class="language-plaintext highlighter-rouge">@comments</code>: an array of all or just a subset of the <code class="language-plaintext highlighter-rouge">Comment</code> objects that exist as children of the <code class="language-plaintext highlighter-rouge">@event</code> object (in reverse chronological order of course).</li>
</ul>

<p>In our <code class="language-plaintext highlighter-rouge">views/comments</code> folder, we have the two partials <code class="language-plaintext highlighter-rouge">_form.html.haml</code> and <code class="language-plaintext highlighter-rouge">_comment.html.haml</code>. <code class="language-plaintext highlighter-rouge">_form</code> expects a local variable named <code class="language-plaintext highlighter-rouge">comment</code> as an input to help build the new comment form. <code class="language-plaintext highlighter-rouge">comment.html.haml</code> is our partial for displaying a single comment. It takes a collection of <code class="language-plaintext highlighter-rouge">comment</code>s and tells the renderer to treat each object in the collection as a <code class="language-plaintext highlighter-rouge">comment</code>.</p>

<h2 id="eventsshow">events#show</h2>

<p>Before we dig into writing each partial, let’s step backwards in the chain of events and go back to our <code class="language-plaintext highlighter-rouge">EventsController</code> to set up those instances variables that the show template will be looking for.</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	# events_controller.rb
	class EventsController &lt; ApplicationController
	  def show
	    @event = Event.find(params[:id])
	    @comments = @event.comment_threads.order('created_at desc')
	    @new_comment = Comment.build_from(@event, current_user.id, "")
	  end
	end
</code></pre>
</div>

<p>The first line of the <code class="language-plaintext highlighter-rouge">show</code> method should be par for the course. We’re pulling the event in question from the database based on the <code class="language-plaintext highlighter-rouge">id</code> provided in the URL. Rails automatically inserts a <code class="language-plaintext highlighter-rouge">render 'show'</code> for us at the end of the method.</p>

<p>The second line looks a little fishy. We’re using a helper method included in <code class="language-plaintext highlighter-rouge">acts_as_commentable_with_threading</code> to get the comments associated with the <code class="language-plaintext highlighter-rouge">@event</code> and order them by date. You might also want to do pagination at this step too, but with our nested event-&gt;comment architecture, it might also warrant an AJAX solution to load more (that’s a topic for another post).</p>

<p>The third line creates a placeholder comment object that acts as sort of a carrier for our parent object info. This new blank comment object will carry with it a reference to the parent <code class="language-plaintext highlighter-rouge">@event</code> and therefore its object type and id, and the current user. The <code class="language-plaintext highlighter-rouge">build_from</code> method is another helper created by <code class="language-plaintext highlighter-rouge">acts_as_commentable_with_threading</code>.</p>

<h2 id="comments_formhtmlhaml">comments/_form.html.haml</h2>

<p>Now we can continue on to our new comment form partial.</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	# _form.html.haml
	.comment-form
	  = simple_form_for comment, :remote =&gt; true do |f|
	    = f.input :body, :input_html =&gt; { :rows =&gt; "2" }, :label =&gt; false
	    = f.input :commentable_id, :as =&gt; :hidden, :value =&gt; comment.commentable_id
	    = f.input :commentable_type, :as =&gt; :hidden, :value =&gt; comment.commentable_type
	    = f.button :submit, :class =&gt; "btn btn-primary", :disable_with =&gt; "Submitting…"
</code></pre>
</div>

<p>Let’s step through line by line.</p>

<p>First, we’ll wrap the form with the <code class="language-plaintext highlighter-rouge">comment-form</code> class.</p>

<p>Next, we’re going to use simple form to create a form block for our comment. Adding <code class="language-plaintext highlighter-rouge">:remote =&gt; true</code> will provide the Rails magic to turn our standard form into an AJAX one. The form_for helper is smart enough in this case to pick the correct URL and HTTP method. We could specify it directly as:</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	= simple_form_for comment, :url =&gt; comment_path, :method =&gt; 'post', :remote =&gt; true do |f|
</code></pre>
</div>

<p>The first input is the textarea for our comment body. Nothing special here, just limiting the rows to 2 and turning the label off.</p>

<p>The next two inputs are hidden from the user and will be included with the form submission to the server. We’re including the <code class="language-plaintext highlighter-rouge">commentable_type</code> or class name of the parent object and its id so that our <code class="language-plaintext highlighter-rouge">CommentsController</code> will know what object to link the new comment to.</p>

<p>Aside: I want to mention that since these hidden inputs are technically open to alteration, they must be properly sanitized by the server before being acted upon. By altering these values, the user could potentially create a new comment on a different object type and/or an object they aren’t allowed to see.</p>

<p>Our last form element is a submit button with Twitter Bootstrap classes for styling. Clicking this will trigger the AJAX action and submit our form data to the <code class="language-plaintext highlighter-rouge">CommentsController</code> for handling. The <code class="language-plaintext highlighter-rouge">disable_with</code> takes care of some of the JS we’d have to write by disabling the submit button.</p>

<p>I’m going to skip the JS for now and move onto the <code class="language-plaintext highlighter-rouge">CommentsController</code> implementation. We’ll get back to the JS in a moment.</p>

<h2 id="commentscontroller">CommentsController</h2>

<p>If you recall earlier, we set up routes to our <code class="language-plaintext highlighter-rouge">CommentsController</code> for two methods: <code class="language-plaintext highlighter-rouge">create</code> and <code class="language-plaintext highlighter-rouge">destroy</code>. Let’s take a look at <code class="language-plaintext highlighter-rouge">create</code>.</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	# comments_controller.rb
	class CommentsController &lt; ApplicationController
	  def create
	    @comment_hash = params[:comment]
	    @obj = @comment_hash[:commentable_type].constantize.find(@comment_hash[:commentable_id])
	    # Not implemented: check to see whether the user has permission to create a comment on this object
	    @comment = Comment.build_from(@obj, current_user.id, @comment_hash[:body])
	    if @comment.save
	      render :partial =&gt; "comments/comment", :locals =&gt; { :comment =&gt; @comment }, :layout =&gt; false, :status =&gt; :created
	    else
	      render :js =&gt; "alert('error saving comment');"
	    end
	  end
	end
</code></pre>
</div>

<p>The first thing we do is grab a reference to the form data. Our form data is in the params hash under the <code class="language-plaintext highlighter-rouge">:comment</code> symbol. We’ll store it as <code class="language-plaintext highlighter-rouge">@comment_hash</code> for use below.</p>

<p>Next we need to derive the parent object where the comment was created. Luckily, we included the commentable_type and commentable_id in our form data. <code class="language-plaintext highlighter-rouge">@comment_hash[:commentable_type]</code> will return the string <code class="language-plaintext highlighter-rouge">"Event"</code>. We can’t call find on a string, so we have to turn it into a symbol that Ruby recognizes. We can use <code class="language-plaintext highlighter-rouge">constantize</code> to do this conversion (it would be a good idea at this point to check to make sure the commentable_type is legitimate). With a fully qualified <code class="language-plaintext highlighter-rouge">Event</code> class we can call the class method <code class="language-plaintext highlighter-rouge">find</code> and pass it the <code class="language-plaintext highlighter-rouge">:commentable_id</code>. Out pops our event object.</p>

<p>The next step is to determine whether the current_user has permission to create the comment on the object. This depends on your authentication system, but should definitely be included.</p>

<p>We now have references to all the objects we need in order to create the comment. We’ll use the <code class="language-plaintext highlighter-rouge">build_from</code> helper method again and give it the object, current_user, and the body of the comment.</p>

<p>We need to save the comment back to the database. If the save is successful, we’re going to do a few things.</p>

<ul>
  <li>Render the single comment partial with our new comment as the local variable. This will give the comment all the markup it needs to be inserted directly into the existing page.</li>
  <li><code class="language-plaintext highlighter-rouge">:layout =&gt; false</code> will tell the renderer not to include all the extra header and footer markup.</li>
  <li><code class="language-plaintext highlighter-rouge">:status =&gt; :created</code> returns the HTTP status code 201 as is proper.</li>
</ul>

<p>If the save is not successful, we need to tell the user that there was a problem. I’m leaving this outside the scope of the post simply because there are several different ways of doing this depending on how you set up your layout. Above, all we’re doing is popping up an alert box to the user. You should consider this an incomplete implementation.</p>

<p>Aside: using Rails to render HTML is a technique opposite that of returning raw JSON and using client-side JS libraries to handle all things view related. You may want to look into something like <a href="http://emberjs.com">Ember.js</a>.</p>

<h2 id="javascript-for-create">JavaScript for create</h2>

<p>We’re finally back to the JavaScript, or more specifically, CoffeeScript. I’m not an expert in either, but for this stuff you don’t need to be one. I’m using CoffeeScript because it makes the code slightly cleaner.</p>

<p>The only CoffeeScript we’re going to write can sit comfortably in the asset pipeline in the <code class="language-plaintext highlighter-rouge">comments.js.coffee</code> file (more specifically, app/assets/javascripts).</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	# comments.js.coffee
	jQuery -&gt;
	  # Create a comment
	  $(".comment-form")
	    .on "ajax:beforeSend", (evt, xhr, settings) -&gt;
	      $(this).find('textarea')
	        .addClass('uneditable-input')
	        .attr('disabled', 'disabled');
	    .on "ajax:success", (evt, data, status, xhr) -&gt;
	      $(this).find('textarea')
	        .removeClass('uneditable-input')
	        .removeAttr('disabled', 'disabled')
	        .val('');
	      $(xhr.responseText).hide().insertAfter($(this)).show('slow')
</code></pre>
</div>

<p>What is code actually doing? We’re simply registering for callbacks on the AJAX requests that will originate from our comment form. When those events occur, we’re going to run functions.</p>

<p><code class="language-plaintext highlighter-rouge">$(.comment-form)</code> targets the <code class="language-plaintext highlighter-rouge">comment-form</code> class we applied to the <code class="language-plaintext highlighter-rouge">div</code> that wraps our comment form partial. This allows us to actually use multiple comment forms on a single page if we want to.</p>

<p><code class="language-plaintext highlighter-rouge">.on</code> is the jQuery function that binds an event to a function. It replaces the older jQuery functions <code class="language-plaintext highlighter-rouge">.bind</code>, <code class="language-plaintext highlighter-rouge">.delegate</code>, and <code class="language-plaintext highlighter-rouge">.live</code>. You can read about it <a href="http://api.jquery.com/on/">here</a>.</p>

<p>The first event we’re binding to is <code class="language-plaintext highlighter-rouge">"ajax:beforeSend"</code>. When the user clicks the submit button, Rails will trigger this event, and our function will be called. The arguments passed to the function (and all the available callbacks) can be found on the <a href="https://github.com/rails/jquery-ujs/wiki/ajax">jquery-ujs wiki</a>.</p>

<p>The function that runs on this event is embedded as anonymous. We could call a function that exists elsewhere just as easily.</p>

<p><code class="language-plaintext highlighter-rouge">$(this)</code> is the jQuery object version of the <code class="language-plaintext highlighter-rouge">.comment-form</code> <code class="language-plaintext highlighter-rouge">div</code> that was involved in the click. Alternatively, we could grab a reference to the form from <code class="language-plaintext highlighter-rouge">$(evt.currentTarget)</code>. We’ll use <code class="language-plaintext highlighter-rouge">$(this)</code> to extract the textarea element in the next line. <code class="language-plaintext highlighter-rouge">.find('textarea')</code> will select <code class="language-plaintext highlighter-rouge">textarea</code> elements within the form. In our case, we only have one. We then chain two functions together to perform two operations on the <code class="language-plaintext highlighter-rouge">textarea</code>s.</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	$(this).find('textarea')
	  .addClass('uneditable-input')
	  .attr('disabled', 'disabled');
</code></pre>
</div>

<p>is equivalent to:</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	$(this).find('textarea').addClass('uneditable-input');
	$(this).find('textarea').attr('disabled', 'disabled');
</code></pre>
</div>

<p><code class="language-plaintext highlighter-rouge">addClass</code> adds the <code class="language-plaintext highlighter-rouge">uneditable-input</code> class to our textarea, which will perform some Bootstrap styling to our textarea, but not actually make it uneditable.</p>

<p><code class="language-plaintext highlighter-rouge">attr</code> adds the <code class="language-plaintext highlighter-rouge">disabled='disabled'</code> element to our textarea actually disabling the user input.</p>

<p>We’re then chaining another <code class="language-plaintext highlighter-rouge">.on</code> for the <code class="language-plaintext highlighter-rouge">ajax:success</code> event that gets called if the AJAX call returns successfully. Our first move is to find the <code class="language-plaintext highlighter-rouge">textarea</code> and undo the temporary disabling (you may want to consider doing this at the <code class="language-plaintext highlighter-rouge">ajax:complete</code> event, because it should be done regardless of whether the AJAX was successful). You’ll notice we chained one additional function <code class="language-plaintext highlighter-rouge">.val('')</code> at the end. This will clear the <code class="language-plaintext highlighter-rouge">textarea</code> in anticipation of the user adding another comment. You wouldn’t want to do that in the error case, because the user should have an opportunity to resubmit the comment without having to retype it.</p>

<p>We’re finally ready to add the nicely formatted comment to the top of our comment feed.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$(xhr.responseText)</code> gets a jQuery object version of the response HTML returned by the server.</li>
  <li><code class="language-plaintext highlighter-rouge">.hide()</code> disappears our new <code class="language-plaintext highlighter-rouge">div</code> so it can be animated in.</li>
  <li><code class="language-plaintext highlighter-rouge">.insertAfter($(this))</code> places our new <code class="language-plaintext highlighter-rouge">div</code> after the comment form. If you want to put it somewhere more specific, you can replace the <code class="language-plaintext highlighter-rouge">$(this)</code> selector with a more specific selector.</li>
  <li><code class="language-plaintext highlighter-rouge">.show('slow')</code> animates our new <code class="language-plaintext highlighter-rouge">div</code> sliding down from the form.</li>
</ul>

<h2 id="_commenthtmlhaml--deletion">_comment.html.haml / deletion</h2>

<p>I skipped our single comment template, so I’ll add it here for completeness. This will lead us into the comment deletion section.</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	# _comment.html.haml
	%div.comment{ :id =&gt; "comment-#{comment.id}" }
	  %hr
	  = link_to "×", comment_path(comment), :method =&gt; :delete, :remote =&gt; true, :confirm =&gt; "Are you sure you want to remove this comment?", :disable_with =&gt; "×", :class =&gt; 'close'
	  %h4
	    = comment.user.username
	    %small= comment.updated_at
	  %p= comment.body
</code></pre>
</div>

<p>Our wrapper div has a <code class="language-plaintext highlighter-rouge">comment</code> class, and a CSS id unique to each comment. We’re not actually going to use that id, but it could be useful in the future.</p>

<p><code class="language-plaintext highlighter-rouge">link_to</code> should look familiar. Our display text is an x. The link will go to the delete path we created earlier in the Routes section. To refresh your memory, it will go to <code class="language-plaintext highlighter-rouge">/comments/:id</code>. <code class="language-plaintext highlighter-rouge">:method =&gt; :delete</code> tells Rails to use the <code class="language-plaintext highlighter-rouge">DELETE</code> HTML method.</p>

<p><code class="language-plaintext highlighter-rouge">:remote =&gt; true</code> performs the Rails AJAX magic like we saw earlier with the creation form. <code class="language-plaintext highlighter-rouge">:confirm</code> pops up a JS alert to confirm the user wants to do remove the comment. <code class="language-plaintext highlighter-rouge">:disable_with</code> makes sure the user can’t try to delete the comment while the server is processing the first request. And the <code class="language-plaintext highlighter-rouge">close</code> class is Bootstrap styling.</p>

<p>Another reminder: you’ll probably want to conditionally display the delete link to the comment creator and admins. <a href="https://github.com/drapergem/draper">Draper</a> is a good option for doing this cleanly.</p>

<p>The rest of the markup should be pretty straightforward.</p>

<h2 id="back-to-commentscontroller">Back to CommentsController</h2>

<p>Time to add the <code class="language-plaintext highlighter-rouge">destroy</code> method to your <code class="language-plaintext highlighter-rouge">CommentsController</code>.</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	# comments_controller.rb
	def destroy
	  @comment = Comment.find(params[:id])
	  if @comment.destroy
	    render :json =&gt; @comment, :status =&gt; :ok
	  else
	    render :js =&gt; "alert('error deleting comment');"
	  end
	end
</code></pre>
</div>

<p><code class="language-plaintext highlighter-rouge">@comment</code> will track down the comment-to-be deleted from the database (check that user is allowed to delete it!).</p>

<p>Then try to destroy the comment. This time, when the call completes successfully, I’m sending raw json back to the client with an <code class="language-plaintext highlighter-rouge">ok</code> status. There are a myriad of options here. Use what’s best for your app.</p>

<p>And on error I’m copping out again and sending back JS.</p>

<p>Aside: if you want to do some informal testing, I recommend throwing a <code class="language-plaintext highlighter-rouge">sleep 5</code> call before the <code class="language-plaintext highlighter-rouge">if</code> statement so you have more time to observe your AJAX.</p>

<h2 id="javascript-for-destroy">JavaScript for destroy</h2>

<p>Back to our <code class="language-plaintext highlighter-rouge">comments.js.coffee</code> file.</p>

<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>	jQuery -&gt;
	  # Create a comment
	  # ...
	
	  # Delete a comment
	  $(document)
	    .on "ajax:beforeSend", ".comment", -&gt;
	      $(this).fadeTo('fast', 0.5)
	    .on "ajax:success", ".comment", -&gt;
	      $(this).hide('fast')
	    .on "ajax:error", ".comment", -&gt;
	      $(this).fadeTo('fast', 1)
</code></pre>
</div>

<p>We’re going to use the other incarnation of <code class="language-plaintext highlighter-rouge">.on</code> for the reason I’ll explain in a moment. This time we’re calling <code class="language-plaintext highlighter-rouge">.on</code> on the whole DOM. We specify our event first as we did before, but now we’ll add the <code class="language-plaintext highlighter-rouge">".comment"</code> selector as the second argument. Again, this applies to all of our comment <code class="language-plaintext highlighter-rouge">div</code>s with the <code class="language-plaintext highlighter-rouge">comment</code> class.</p>

<p>We’re not going to bother including the arguments to the <code class="language-plaintext highlighter-rouge">ajax</code> event callbacks (for example <code class="language-plaintext highlighter-rouge">(evt, xhr, settings)</code>); we don’t need them.</p>

<p><code class="language-plaintext highlighter-rouge">$(this)</code> refers to the comment <code class="language-plaintext highlighter-rouge">div</code> that generated the event. We’re going fade the entire comment to half opacity before sending the request to the server by calling <code class="language-plaintext highlighter-rouge">.fadeTo('fast', 0.5)</code>. On success, we’ll animate the comment fading the rest of the way out and disappearing to show the user the request was completed succesfully. On error, we’ll fade the comment back to full opacity to show that the comment still exists.</p>

<p>The reason we used <code class="language-plaintext highlighter-rouge">$(document)</code> this time instead of calling <code class="language-plaintext highlighter-rouge">.on</code> on the selector directly is because it will apply the callback to newly created DOM elements as well. For example, I can add a comment and then immediately delete it without refreshing the page.</p>

<h2 id="wrap-up">Wrap up</h2>

<p>This turned out to be quite the mega-post. I may have gone into too much detail, but I’m hoping this has enlightened any new Rails devs out there.</p>

<p>We didn’t actually write that much JavaScript, and most of it was simply for decoration. But this should give you the building blocks you need to add more interesting functionality on AJAX triggers. I highly recommend <a href="http://oscarotero.com/jquery">this jQuery reference/overview</a>.</p>

<p>Discuss this on <a href="http://news.ycombinator.com/item?id=4798823">Hacker News</a>.</p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">twocentstudios</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:chris@twocentstudios.com">chris@twocentstudios.com</a></li>
          
          <li>
            <a href="https://github.com/twocentstudios">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          

          <li>
            <a href="https://hackyderm.io/@twocentstudios">
              <span class="icon">
                <svg viewBox="0 0 24 24">
                  <path fill="#828282" d="M21.327 8.566c0-4.339-2.843-5.61-2.843-5.61-1.433-.658-3.894-.935-6.451-.956h-.063c-2.557.021-5.016.298-6.45.956 0 0-2.843 1.272-2.843 5.61 0 .993-.019 2.181.012 3.441.103 4.243.778 8.425 4.701 9.463 1.809.479 3.362.579 4.612.51 2.268-.126 3.541-.809 3.541-.809l-.075-1.646s-1.621.511-3.441.449c-1.804-.062-3.707-.194-3.999-2.409a4.523 4.523 0 0 1-.04-.621s1.77.433 4.014.536c1.372.063 2.658-.08 3.965-.236 2.506-.299 4.688-1.843 4.962-3.254.434-2.223.398-5.424.398-5.424zm-3.353 5.59h-2.081V9.057c0-1.075-.452-1.62-1.357-1.62-1 0-1.501.647-1.501 1.927v2.791h-2.069V9.364c0-1.28-.501-1.927-1.502-1.927-.905 0-1.357.546-1.357 1.62v5.099H6.026V8.903c0-1.074.273-1.927.823-2.558.566-.631 1.307-.955 2.228-.955 1.065 0 1.872.409 2.405 1.228l.518.869.519-.869c.533-.819 1.34-1.228 2.405-1.228.92 0 1.662.324 2.228.955.549.631.822 1.484.822 2.558v5.253z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>

          
          <li>
            <a href="https://twitter.com/twocentstudios">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          
        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
