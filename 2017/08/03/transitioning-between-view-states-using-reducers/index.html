<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Transitioning Between View States Using Reducers</title>

  <meta property="og:type" content="article" />
  <meta property="og:title" content="Transitioning Between View States Using Reducers" />
  <meta property="og:url" content="https://twocentstudios.com/2017/08/03/transitioning-between-view-states-using-reducers/" />
  
    <meta property="og:article:published_time" content="2017-08-03T07:40:30+09:00" />
  
  
  
  <link href='https://fonts.googleapis.com/css2?family=Work+Sans:wght@300;350;400;600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://twocentstudios.com/2017/08/03/transitioning-between-view-states-using-reducers/">
  <link rel="alternate" type="application/rss+xml" title="twocentstudios" href="https://twocentstudios.com/feed.xml" />
</head>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NE82N02W8S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NE82N02W8S');
</script>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">twocentstudios</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/blog/">Blog</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/portfolio/">Portfolio</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Transitioning Between View States Using Reducers</h1>
    <p class="post-meta">Aug 3, 2017</p>
  </header>

  <article class="post-content">
    <p>In this post we’ll take a look at a technique to model transitions between view states in Swift. We’ll also look at how to model the commands that will initiate view state transitions, and the effects that will be produced by view state transitions.</p>

<p>In the <a href="/2017/07/24/modeling-view-state/">last post</a> we looked at modeling the view states themselves. We’ll revisit some of that code and build upon it in this post, but I would encourage you to read that post before continuing.</p>

<p>In subsequent posts, we’ll look at how to use our view models from the previous post and reducers from this post to create a full state machine in what we’ll call an interactor.</p>

<h2 id="background">Background</h2>

<p>In the last post, we ended up with a user profile screen that encapsulated two separate pieces of information: the user’s profile data and the user’s posts. Each has its own associated view states including <code class="language-plaintext highlighter-rouge">initialized</code>, <code class="language-plaintext highlighter-rouge">loading</code>, <code class="language-plaintext highlighter-rouge">loaded</code>, and <code class="language-plaintext highlighter-rouge">failed</code>.</p>

<div class="caption-wrapper"><img class="caption" src="/images/modeling_view_state-06.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>We have some view states, and now we need a way to describe how we’re allowed to transition in between those view states.</p>

<p>Let’s look at a technique we can use to formalize these view state transitions. We’ll call this technique a <strong>reducer</strong>. A reducer will:</p>

<ul>
  <li>List all commands that can <em>change</em> the view model state (<code class="language-plaintext highlighter-rouge">Command</code>).</li>
  <li>List all effects that describe <em>side-effects</em> of view model state transitions (<code class="language-plaintext highlighter-rouge">Effect</code>).</li>
  <li>Determine all valid transitions between view model states (<code class="language-plaintext highlighter-rouge">ViewModel.State</code> &amp; <code class="language-plaintext highlighter-rouge">State</code>).</li>
</ul>

<p>There is lots of prior art on reducers, mostly from the functional programming world (I’ve included several links at the end of this post). In the context of finite state machines they’re called <em>transducers</em>. We’re going to use <em>reducer</em> in this post because of the rising popularity of Redux, Elm, ReSwift, etc. The name itself is just a name, and we’ll focus as much as possible on the attributes and the responsibilities of reducers.</p>

<h2 id="goals">Goals</h2>

<p>In many architectures, transitioning between view states is done on an adhoc basis.</p>

<ul>
  <li>Often the previous view state is not consulted before transitioning to a view state, the result of which can be invalid view states, confusing transitions, or unwanted side-effects.</li>
  <li>Sometimes it’s not even possible to determine a cohesive representation of the view state because it must be derived from the property values of several unrelated <code class="language-plaintext highlighter-rouge">UIKit</code> controls (e.g. <code class="language-plaintext highlighter-rouge">UISwitch.isOn</code>, <code class="language-plaintext highlighter-rouge">UILabel.text</code>, etc.).</li>
  <li>The code for making view state transitions is scattered throughout a view controller and mixed in with unrelated static view configuration code.</li>
  <li>Updating the model (and any additional overhead) must be done on the main thread, or a complex system of locking must be mixed in with the view code.</li>
  <li>There is no way to unit test the logic (or lack thereof) that controls view state transitions, especially because it is mixed in with asynchronous operations.</li>
</ul>

<p>Our goal is to define a strict interface for a system that will describe valid view state transitions. The inputs and outputs to the system will be value-types and therefore the whole system will be easily testable.</p>

<p>This system is not necessarily complex. You’ll see in the implementation below that our reducer:</p>

<ul>
  <li>Is one static function.</li>
  <li>Works only with value types.</li>
  <li>Is synchronous.</li>
  <li>Is stateless.</li>
</ul>

<h2 id="definitions">Definitions</h2>

<p>Before diving into code, let’s run through some new terms that will help us distinguish how data will flow through the reducer.</p>

<h3 id="view-model">View model</h3>

<p>We went into detail about view models <a href="/2017/07/24/modeling-view-state/">in the last post</a>. The view model is a value type that transforms a view state into some output data that is easily consumable by an object in the view layer. A view model represents a view’s state at one moment in time.</p>

<h3 id="command">Command</h3>

<p><code class="language-plaintext highlighter-rouge">Command</code> lists the valid events that can cause transitions between view states. Alongside the view model and effect, it is one of the inputs of the reducer function.</p>

<h3 id="effect">Effect</h3>

<p><code class="language-plaintext highlighter-rouge">Effect</code> lists the valid side-effects that occur alongside a view state transition. It is primarily used as an output of the reducer, but due mostly to implementation details, it is also provided as an input to the reducer. There may be some rare situation where knowing the last effect would be useful in making a view state transition, but usually it will be ignored as an input.</p>

<h3 id="state">State</h3>

<p><code class="language-plaintext highlighter-rouge">State</code> combines a view model and an optional effect. One input and the output of the reducer are of type State. Note that <code class="language-plaintext highlighter-rouge">Reducer.State</code> is a different concept than <code class="language-plaintext highlighter-rouge">ViewModel.State</code>.</p>

<h3 id="reducer">Reducer</h3>

<p>The general definition of a reducer is a function that takes a <code class="language-plaintext highlighter-rouge">Command</code> and a <code class="language-plaintext highlighter-rouge">State</code> and produces a new <code class="language-plaintext highlighter-rouge">State</code>.</p>

<div class="caption-wrapper"><img class="caption" src="/images/transitioning_view_states-01.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>Our reducer’s <code class="language-plaintext highlighter-rouge">State</code> combines both <code class="language-plaintext highlighter-rouge">ViewModel</code> and <code class="language-plaintext highlighter-rouge">Effect</code>. So it’s better for us to look at the reducer’s inputs and outputs more like this:</p>

<div class="caption-wrapper"><img class="caption" src="/images/transitioning_view_states-02.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>We’ll come back to these diagrams in a moment when we get to the implementation.</p>

<h2 id="general-implementation">General Implementation</h2>

<p>Another goal of this technique is that it can be used as a template throughout an app. The contents of each view model, effect, and command will be different, but the structure will be the same.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ViewModelReducer</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Command</span> <span class="p">{</span> 
        <span class="c1">// cases:</span>
        <span class="c1">// what events can cause this view model to change? </span>
    <span class="p">}</span>
    
    <span class="kd">enum</span> <span class="kt">Effect</span> <span class="p">{</span>  
        <span class="c1">// cases: </span>
        <span class="c1">// what side-effects occur alongside state changes?</span>
    <span class="p">}</span>
    
    <span class="kd">struct</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModel</span>
        <span class="k">let</span> <span class="nv">effect</span><span class="p">:</span> <span class="kt">Effect</span><span class="p">?</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">,</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">Command</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="c1">// Determine a new output State based on each input State &amp; Command combination.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The benefit here is that the process of writing new reducers is formalized around designing a well-specified state machine. Once you’ve designed the system, writing the code becomes the easy part.</p>

<p>Notice that the <code class="language-plaintext highlighter-rouge">ViewModelReducer</code> struct acts as a namespace. It has no properties or initializers. (It might be more syntactically correct for it to be an <code class="language-plaintext highlighter-rouge">enum</code> instead with no cases, but for now we’ll keep it as a struct).</p>

<h2 id="profile-implementation">Profile Implementation</h2>

<p>Let’s implement the <code class="language-plaintext highlighter-rouge">ProfileViewModel</code>: the top half of the user view.</p>

<div class="caption-wrapper"><img class="caption" src="/images/modeling_view_state-06.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>The view model we created last time:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ProfileViewModel</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">initialized</span>
        <span class="k">case</span> <span class="n">loading</span>
        <span class="k">case</span> <span class="nf">loaded</span><span class="p">(</span><span class="kt">User</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">failed</span><span class="p">(</span><span class="kt">Error</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">enum</span> <span class="kt">ViewModelType</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    
    <span class="k">let</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">State</span>
    
    <span class="k">let</span> <span class="nv">viewModels</span><span class="p">:</span> <span class="p">[</span><span class="kt">ViewModelType</span><span class="p">]</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>At the moment, we’re only concerned with the <code class="language-plaintext highlighter-rouge">state</code> part as it’s the input to <code class="language-plaintext highlighter-rouge">ProfileViewModel</code>. The <code class="language-plaintext highlighter-rouge">viewModels</code> property is the output used by the view layer.</p>

<p>First, we’ll copy/paste the template struct from above.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Skeleton implementation</span>
<span class="kd">struct</span> <span class="kt">ProfileViewModelReducer</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Command</span> <span class="p">{</span> 
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">enum</span> <span class="kt">Effect</span> <span class="p">{</span>  
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">struct</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span>
        <span class="k">let</span> <span class="nv">effect</span><span class="p">:</span> <span class="kt">Effect</span><span class="p">?</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">,</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">Command</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Next, let’s map out the state from <code class="language-plaintext highlighter-rouge">ProfileViewModel.State</code>.</p>

<div class="caption-wrapper"><img class="caption" src="/images/transitioning_view_states-03.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<ul>
  <li>Our entry point is <code class="language-plaintext highlighter-rouge">Initialized</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Initialized</code> can only go to <code class="language-plaintext highlighter-rouge">Loading</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Loading</code> can transition to either <code class="language-plaintext highlighter-rouge">Loaded</code> or <code class="language-plaintext highlighter-rouge">Failed</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Loaded</code> or <code class="language-plaintext highlighter-rouge">Failed</code> may transition back through <code class="language-plaintext highlighter-rouge">Loading</code>.</li>
</ul>

<p>Next, let’s name the commands that will trigger these transitions.</p>

<div class="caption-wrapper"><img class="caption" src="/images/transitioning_view_states-04.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">Load</code> command can be issued from three states.</li>
  <li><code class="language-plaintext highlighter-rouge">Loaded</code> and <code class="language-plaintext highlighter-rouge">Failed</code> commands are only valid when the current state is <code class="language-plaintext highlighter-rouge">Loading</code>.</li>
</ul>

<p>Let’s go ahead and add these commands to our implementation.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Added `Command`</span>
<span class="kd">struct</span> <span class="kt">ProfileViewModelReducer</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Command</span> <span class="p">{</span> 
        <span class="k">case</span> <span class="n">load</span>
        <span class="k">case</span> <span class="nf">loaded</span><span class="p">(</span><span class="kt">User</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">failed</span><span class="p">(</span><span class="kt">Error</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">enum</span> <span class="kt">Effect</span> <span class="p">{</span>  
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">struct</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span>
        <span class="k">let</span> <span class="nv">effect</span><span class="p">:</span> <span class="kt">Effect</span><span class="p">?</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">,</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">Command</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Effect is next.</p>

<p>When we receive <code class="language-plaintext highlighter-rouge">Command.load</code>, we want to both change the view state to <code class="language-plaintext highlighter-rouge">.loading</code> <em>and</em> kick off an asynchronous network request to load the data. Our reducer is synchronous though, so we’ll use the <code class="language-plaintext highlighter-rouge">Effect</code> mechanism to specify exactly what asynchronous operation should be carried out on the reducer’s behalf.</p>

<p>In this case, it’s enough to simply define <code class="language-plaintext highlighter-rouge">Effect.load</code> with no enum case associated values.</p>

<p>There’s are no other asynchronous requests we need to make in order to make all the other possible transitions, so the <code class="language-plaintext highlighter-rouge">Effect</code> enum will only have one case this time.</p>

<p>Below is a diagram of one state transition from <code class="language-plaintext highlighter-rouge">.initialized</code> to <code class="language-plaintext highlighter-rouge">.loading</code>.</p>

<div class="caption-wrapper"><img class="caption" src="/images/transitioning_view_states-05.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>And our updated reducer code:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Added `Effect`</span>
<span class="kd">struct</span> <span class="kt">ProfileViewModelReducer</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Command</span> <span class="p">{</span> 
        <span class="k">case</span> <span class="n">load</span>
        <span class="k">case</span> <span class="nf">loaded</span><span class="p">(</span><span class="kt">User</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">failed</span><span class="p">(</span><span class="kt">Error</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">enum</span> <span class="kt">Effect</span> <span class="p">{</span>  
        <span class="k">case</span> <span class="n">load</span>
    <span class="p">}</span>
    
    <span class="kd">struct</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span>
        <span class="k">let</span> <span class="nv">effect</span><span class="p">:</span> <span class="kt">Effect</span><span class="p">?</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">,</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">Command</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We’re finally ready to implement the <code class="language-plaintext highlighter-rouge">reduce</code> function.</p>

<p>In the <code class="language-plaintext highlighter-rouge">reduce</code> function we’ll see that Swift’s enums really shine. <code class="language-plaintext highlighter-rouge">switch</code>ing over <code class="language-plaintext highlighter-rouge">ViewModel.State</code> and <code class="language-plaintext highlighter-rouge">Command</code> allows the compiler to help us out and ensure we’ve covered all possible combinations (however, if you’re in a rush, you can always specify the known states and use a <code class="language-plaintext highlighter-rouge">default</code> case to cover the rest).</p>

<p>It’s possible to <code class="language-plaintext highlighter-rouge">switch</code> through the cases as <code class="language-plaintext highlighter-rouge">Command</code> then <code class="language-plaintext highlighter-rouge">ViewModel.State</code> or the reverse <code class="language-plaintext highlighter-rouge">ViewModel.State</code> then <code class="language-plaintext highlighter-rouge">Command</code>. At the moment I prefer the former (and have written it below as such), but the latter may be easier to read after some time away from the code.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">func</span> <span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">,</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">Command</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="p">{</span>

    <span class="c1">// Unpack the arguments (we intentionally don't use `Effect` as an input).</span>
    <span class="k">let</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">viewModel</span>
    <span class="k">let</span> <span class="nv">_</span><span class="p">:</span> <span class="kt">Effect</span><span class="p">?</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">effect</span>
    <span class="k">let</span> <span class="nv">viewModelState</span><span class="p">:</span> <span class="kt">ProfileViewModel</span><span class="o">.</span><span class="kt">State</span> <span class="o">=</span> <span class="n">viewModel</span><span class="o">.</span><span class="n">state</span>
    
    <span class="c1">// Create a convenience output `State` for invalid transitions.</span>
    <span class="k">let</span> <span class="nv">noChange</span> <span class="o">=</span> <span class="kt">State</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">,</span> <span class="nv">effect</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    
    <span class="c1">// Switch over `command` then `viewModelState`.</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">viewModelState</span><span class="p">)</span> <span class="p">{</span>
        
    <span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">load</span><span class="p">,</span> <span class="o">.</span><span class="n">initialized</span><span class="p">),</span>
         <span class="p">(</span><span class="o">.</span><span class="n">load</span><span class="p">,</span> <span class="o">.</span><span class="n">loaded</span><span class="p">),</span>
         <span class="p">(</span><span class="o">.</span><span class="n">load</span><span class="p">,</span> <span class="o">.</span><span class="n">failed</span><span class="p">):</span>
        <span class="k">return</span> <span class="kt">State</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="n">loading</span><span class="p">),</span> <span class="nv">effect</span><span class="p">:</span> <span class="o">.</span><span class="n">load</span><span class="p">)</span>
        
    <span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">load</span><span class="p">,</span> <span class="o">.</span><span class="n">loading</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">noChange</span> <span class="c1">// ignore `.load` command if we're already in a loading state.</span>
        
    <span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="nf">loaded</span><span class="p">(</span><span class="k">let</span> <span class="nv">user</span><span class="p">),</span> <span class="o">.</span><span class="n">loading</span><span class="p">):</span>
        <span class="k">return</span> <span class="kt">State</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="nf">loaded</span><span class="p">(</span><span class="n">user</span><span class="p">)),</span> <span class="nv">effect</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        
    <span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">loaded</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">noChange</span> <span class="c1">// `.loaded` command can not be handled from any other view state besides `.loading`.</span>
        
    <span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="nf">failed</span><span class="p">(</span><span class="k">let</span> <span class="nv">error</span><span class="p">),</span> <span class="o">.</span><span class="n">loading</span><span class="p">):</span>
        <span class="k">return</span> <span class="kt">State</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="o">.</span><span class="nf">failed</span><span class="p">(</span><span class="n">error</span><span class="p">)),</span> <span class="nv">effect</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        
    <span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">failed</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">noChange</span> <span class="c1">// `.failed` command can not be handled from any other view state besides `.loading`.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In the above implementation:</p>

<ul>
  <li>We covered all combinations of the 3 <code class="language-plaintext highlighter-rouge">Command</code>s and 4 <code class="language-plaintext highlighter-rouge">ViewModel.State</code>s.</li>
  <li>Invalid transitions are handled by not changing the view model and performing no side-effects (<code class="language-plaintext highlighter-rouge">noChange</code>). You may also consider adding <code class="language-plaintext highlighter-rouge">assertionFailure</code>s to catch these attempted transitions during development if you believe they should never happen.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">ProfileViewModelReducer</code> is fully implemented and can be used in a dedicated interactor which will complete the state machine.</p>

<p>The above combination of <code class="language-plaintext highlighter-rouge">Command</code>s and <code class="language-plaintext highlighter-rouge">ViewModel.State</code>s is quite common and covers a lot of cases in every day iOS development. However, you’ll find plenty of subtle differences when implementing different screens. I’d like to cover some more complicated cases in an advanced post in the future.</p>

<h2 id="why-use-effect">Why use Effect?</h2>

<p>You may be wondering why we need <code class="language-plaintext highlighter-rouge">Effect</code> at all. Why not just derive side-effects directly from the view model’s state?</p>

<p>It’s sometimes possible to use view model directly, but in my experience mixing <a href="https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning">idempotent</a> state changes with non-idempotent side-effects ends up being more complex than treating them separately.</p>

<p>In the example above, let’s say we decide to kick off a network operation if the view model state becomes <code class="language-plaintext highlighter-rouge">loading</code> (this operation happens outside of the reducer). If a <code class="language-plaintext highlighter-rouge">Command.load</code> is processed by the reducer once, then again, the output state will become <code class="language-plaintext highlighter-rouge">loading</code> then remain <code class="language-plaintext highlighter-rouge">loading</code>. With our simple logic, we will kick off two network requests. Is that what we want in all cases? Probably not.</p>

<p>In order to solve this problem, we would have to introduce more state checking in the code that kicks off the network operation. We’re now comparing the old state to the new state, but we’re already doing that inside the reducer! We’re now spreading business logic outside the reducer when our goal was the opposite.</p>

<p>The reducer is the best place to determine the next state <em>and</em> any side-effects that occur based on state changes.</p>

<h2 id="separating-request-and-response">Separating Request and Response</h2>

<p>It may be a little difficult to understand how the asynchronous network request fits into this reducer, especially after seeing that the reducer itself is synchronous. The short answer is that we’ll see in the next post about interactors.</p>

<p>But to give a brief preview, the way we’ll handle asynchronous operations is by separating the request from its response. In the eyes of the reducer, the network request is just another <code class="language-plaintext highlighter-rouge">Effect</code>. In the eyes of the reducer, the response to that network request is just another <code class="language-plaintext highlighter-rouge">Command</code> that will potentially change the view state <em>depending on when that <code class="language-plaintext highlighter-rouge">Command</code> is received</em>. Anything could have happened to the view state while the asynchronous request was being made. Any situation like this will be handled in the same way: as just another input at some point in time.</p>

<p>In a simple view model like our example, it may seem like overkill to split the request and response. But think about a recent occasion when you’ve had to change some state based on multiple asynchronous requests triggered from multiple places in your view controller. How easy was it to make these changes in a performant and thread-safe manner? How sure were you that you had handled all the edge cases? How easy was it to test? How easy would it be to change this code based on new requirements?</p>

<h2 id="pros-and-cons-of-reducers">Pros and Cons of Reducers</h2>

<h3 id="pros">Pros</h3>

<ul>
  <li><strong>Testing</strong> - Using value types as input/output messages to a stateless static function makes this logic trivial to test. It’s so trivial you’ll think you’ve done something wrong. You can write a test for each valid transition in complete isolation.</li>
  <li><strong>Modifying code</strong> - Adding new inputs or new view states is difficult, but in a good way. The Swift compiler will guide you through the process by ensuring you’ve still handled all possible combinations of commands and view states. Your tests will ensure you haven’t broken any existing transitions.</li>
  <li><strong>Reading code</strong> - Your view state transition code is easy to find: it’s in the reducer. It’s keyed by command and view state. You don’t have to hunt through a 1000 line view controller to determine which of several possible functions could be changing your view state.</li>
  <li><strong>Modeling state, transitions, and effects</strong> - Modeling each of these concerns separately allows us to give each the proper consideration and do so in isolation.</li>
  <li><strong>Templated problem solving</strong> - I really love having a template I can follow to solve problems step by step. I can only fit so much in my head at once. Starting from modeling all states of a view then moving on to all the ways that view state can be changed allows me to focus on one problem at a time and be confident that there are no edge cases I haven’t handled. The Swift compiler always has my back.</li>
</ul>

<h3 id="cons">Cons</h3>

<p>Similar to our last post:</p>

<ul>
  <li><strong>More code</strong> - There is lots more code to maintain. To be clear though, all of the conditions handled by this new code are either implicitly handled or completely disregarded in most other architectures.</li>
  <li><strong>One big switch</strong> - Some programmers consider switch statements, especially long ones, to be a code smell. I’d like to hear more opinions about whether a switch statement in this context is frowned upon and why.</li>
  <li><strong>Exponentially increasing transition cases</strong> - As more commands and more view states are added, the number of possible transitions that must be handled by your reducer can start to become overwhelming. When you feel overwhelmed, it may be a sign that your view model can be split into two and nested in a parent view model.</li>
  <li><strong>Difficult to understand</strong> - I believe that with the right surrounding documentation (hopefully this blog post), this technique is conceptually simple, especially to programmers with some background in functional programming. However, I can imagine that dropping a developer into this code may be a confusing and frustrating endeavor.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>In this post, we discussed using reducers as a single location to describe view state transitions and any side-effects based on those transitions.</p>

<p>We looked at a reusable skeleton implementation for a reducer and its four parts: <code class="language-plaintext highlighter-rouge">Command</code>, <code class="language-plaintext highlighter-rouge">ViewModel</code>, <code class="language-plaintext highlighter-rouge">Effect</code>, and <code class="language-plaintext highlighter-rouge">State</code>. We looked at the reducer function itself and the way we can use <code class="language-plaintext highlighter-rouge">switch</code> to handle all transitions (both valid and invalid) of the state machine.</p>

<h3 id="further-reading">Further reading</h3>

<ul>
  <li><a href="https://www.cocoawithlove.com/blog/statements-messages-reducers.html">Cocoa with Love: Statements, messages, and reducers</a></li>
  <li><a href="https://medium.com/bpxl-craft/the-value-is-the-boundary-7c4d65322896">BPXL Craft: The Value is the Boundary</a></li>
  <li><a href="https://github.com/inamiy/ReactiveAutomaton">inamiy: ReactiveAutomaton</a></li>
  <li><a href="http://chris.eidhof.nl/post/reducers/">Chris Eidhof: Reducers</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Finite-state_machine">Wikipedia: Finite State Machine</a></li>
  <li><a href="https://github.com/ReSwift/ReSwift">ReSwift</a></li>
  <li><a href="https://github.com/reactjs/redux">Redux</a></li>
</ul>

<p>Thanks for reading this post, and please let me know your thoughts and suggestions. I’m <a href="https://twitter.com/twocentstudios">@twocentstudios</a> on Twitter.</p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">twocentstudios</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:chris@twocentstudios.com">chris@twocentstudios.com</a></li>
          
          <li>
            <a href="https://github.com/twocentstudios">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          

          <li>
            <a href="https://hackyderm.io/@twocentstudios">
              <span class="icon">
                <svg viewBox="0 0 24 24">
                  <path fill="#828282" d="M21.327 8.566c0-4.339-2.843-5.61-2.843-5.61-1.433-.658-3.894-.935-6.451-.956h-.063c-2.557.021-5.016.298-6.45.956 0 0-2.843 1.272-2.843 5.61 0 .993-.019 2.181.012 3.441.103 4.243.778 8.425 4.701 9.463 1.809.479 3.362.579 4.612.51 2.268-.126 3.541-.809 3.541-.809l-.075-1.646s-1.621.511-3.441.449c-1.804-.062-3.707-.194-3.999-2.409a4.523 4.523 0 0 1-.04-.621s1.77.433 4.014.536c1.372.063 2.658-.08 3.965-.236 2.506-.299 4.688-1.843 4.962-3.254.434-2.223.398-5.424.398-5.424zm-3.353 5.59h-2.081V9.057c0-1.075-.452-1.62-1.357-1.62-1 0-1.501.647-1.501 1.927v2.791h-2.069V9.364c0-1.28-.501-1.927-1.502-1.927-.905 0-1.357.546-1.357 1.62v5.099H6.026V8.903c0-1.074.273-1.927.823-2.558.566-.631 1.307-.955 2.228-.955 1.065 0 1.872.409 2.405 1.228l.518.869.519-.869c.533-.819 1.34-1.228 2.405-1.228.92 0 1.662.324 2.228.955.549.631.822 1.484.822 2.558v5.253z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>

          
          <li>
            <a href="https://twitter.com/twocentstudios">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          
        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
