<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Stateless Coordinators</title>
  <meta name="description" content="In this post, I’m presenting an experimental iOS architecture I’m calling Stateless Coordinators. Consider what I’ll present as still a work in progress. Alo...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://twocentstudios.com/2017/03/09/stateless-coordinators/">
  <link rel="alternate" type="application/rss+xml" title="twocentstudios" href="http://twocentstudios.com/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">twocentstudios</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/blog/">Blog</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/portfolio/">Portfolio</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Stateless Coordinators</h1>
    <p class="post-meta">Mar 9, 2017</p>
  </header>

  <article class="post-content">
    <p>In this post, I’m presenting an experimental iOS architecture I’m calling <strong>Stateless Coordinators</strong>. Consider what I’ll present as still a work in progress. Along the way I’ll be posing questions and considerations for changes or improvements.</p>

<blockquote>
  <p>Note: all code in this post targets Swift 3.0.1 and ReactiveSwift 1.1</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>The goal of this architecture is to abstract out the presentation and flow responsibility of <code class="highlighter-rouge">UIViewController</code> and its subclasses in order to make the view layer of the application more composable.</p>

<p>The proposed architecture is an alternate take on the Coordinator Pattern. I found inspiration in the following posts:</p>

<ul>
  <li><a href="http://khanlou.com/2015/10/coordinators-redux/">Coodinators Redux</a></li>
  <li><a href="http://irace.me/navigation-coordinators">Navigation Coordinators</a></li>
  <li><a href="https://hackernoon.com/a-pragmatic-functional-reactive-architecture-with-swift-1e564cdbb1a4">A Pragmatic Functional Reactive Architecture in Swift</a></li>
  <li><a href="http://merowing.info/2016/01/improve-your-ios-architecture-with-flowcontrollers/">Improve your iOS Architecture with FlowControllers</a></li>
</ul>

<h2 id="tools">Tools</h2>

<p>The tools we’ll use are:</p>

<ul>
  <li>Reactive programming; specifically <a href="https://github.com/ReactiveCocoa/ReactiveSwift">ReactiveSwift</a></li>
  <li>Swift enums</li>
  <li>Stateless coordinator modules</li>
</ul>

<p>We’ll specifically be avoiding:</p>

<ul>
  <li>The delegate pattern</li>
  <li>Stateful coordinator objects</li>
</ul>

<p>The reasons for using and not-using these tools will be discussed along the way.</p>

<blockquote>
  <p>If you aren’t familiar with ReactiveSwift, some of the code I’ll present will look like magic, but hopefully will still be comprehensible.</p>
</blockquote>

<h2 id="responsibilities">Responsibilities</h2>

<p>At this point, I’m only going to discuss two major components to the architecture: the <code class="highlighter-rouge">UIViewController</code> family and coordinators. In the future I’d like to expand more on other ways to extract responsibilities from <code class="highlighter-rouge">UIViewController</code> (specifically view models), but for the purposes of this post, let’s assume that the view controller is responsible in one way or another for everything besides managing the presentation flow of itself or its children.</p>

<p>Before jumping into code, let’s enumerate the responsibilities of coordinators and view controllers.</p>

<p>A coordinator will be responsible for:</p>

<ul>
  <li>Declaring a specific set of inputs and outputs that it knows how to handle.</li>
  <li>Accepting dependencies required by the view controller.</li>
  <li>Creating a view controller of a specific identity and providing it its dependencies.</li>
  <li>Creating a signal flow between view controller outputs and inputs with any required transformations in between.</li>
  <li>Application flow side effects: presenting, dismissing, pushing, or popping child view controllers, but not itself.</li>
  <li>Data modification side effects: performing any other side effects that don’t belong to a specific view (this one is a little hazy at the moment).</li>
</ul>

<p>A view controller will be responsible for:</p>

<ul>
  <li>Declaring a specific set of inputs and outputs that it knows how to handle.</li>
  <li>Managing a view hierarchy and keeping it updated.</li>
  <li>Fetching data.</li>
  <li>Handling user touch input.</li>
</ul>

<h2 id="how-does-it-work">How does it work?</h2>

<p>One of the trademarks of a reactive architecture is “setting up the world” so to speak when initializing a system. Essentially wiring together inputs and outputs so that dynamic events and behavior is routed at runtime.</p>

<p>We have two seemingly conflicting goals:</p>

<ul>
  <li>Leverage standard UIKit view controller lifecycle and presentation.</li>
  <li>Remove the presentation responsibility from view controller subclasses.</li>
</ul>

<p>Our strategy will be to create a standardized public extension point on each view controller in which we can add behavior at view controller creation time. The extension point will be a <code class="highlighter-rouge">Signal</code> and we’ll add behaviors by attaching observers. By tying the lifetime of these behaviors to their view controller, we can avoid the common difficulties of working against UIKit patterns.</p>

<p>That strategy probably doesn’t make sense yet. It’s okay because we’re going to go through lots of code examples.</p>

<h2 id="code-examples">Code examples</h2>

<p>A goal of this architecture it to provide a template for modules of our system that is both predictable and flexible. Simple modules should not be overloaded with boilerplate and complex modules should not be unimplementable and degrade into spaghetti.</p>

<p>I’m going to illustrate some examples from simple to complex, introducing one or two unique aspects of this architecture at a time. We’ll start with four view controller examples then move on to coordinators.</p>

<h3 id="view-controller">View controller</h3>

<h4 id="basic-template">Basic template</h4>

<p>All of our view controllers will have the shape of the code below. We’ll add more as the complexity of this module increases.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">ReactiveSwift</span>
<span class="kd">import</span> <span class="kd">enum</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">NoError</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Inputs</span> <span class="p">{</span>
    <span class="p">}</span>
    
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">inputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">inputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="k">let</span> <span class="nv">outputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">outputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">inputSignal</span><span class="p">,</span> <span class="n">inputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        <span class="p">(</span><span class="n">outputSignal</span><span class="p">,</span> <span class="n">outputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The first thing to note is each view controller specifically declares what dynamic inputs it accepts and what dynamic outputs it provides to the outside world. The template view controller above is completely static with no input or output cases. Because these enums are nested within the view controller, they can always be named <code class="highlighter-rouge">Inputs</code> and <code class="highlighter-rouge">Outputs</code>.</p>

<p>Next, we have a <code class="highlighter-rouge">Signal</code>/<code class="highlighter-rouge">Observer</code> pair for inputs and one for outputs. The <code class="highlighter-rouge">private</code>/<code class="highlighter-rouge">internal</code> distinctions are intentional: the outside world can send inputs (of type <code class="highlighter-rouge">Inputs</code>) on <code class="highlighter-rouge">inputObserver</code> and can observe outputs (of type <code class="highlighter-rouge">Outputs</code>) on <code class="highlighter-rouge">outputSignal</code>.</p>

<p>As stated in the type signature (<code class="highlighter-rouge">NoError</code>), these signals can’t error. They are also not intended to complete before the view controller has deallocated, but we’ll have to take some additional steps to guarantee that behavior.</p>

<h4 id="one-button-one-output">One button, one output</h4>

<p>Now, let’s say we have a view controller with one static button that says “start”.</p>

<div class="caption-wrapper"><img class="caption" src="/images/stateless_coordinators-01.jpg" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">StartViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Inputs</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">tappedStart</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">inputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">inputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="k">let</span> <span class="nv">outputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">outputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">inputSignal</span><span class="p">,</span> <span class="n">inputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        <span class="p">(</span><span class="n">outputSignal</span><span class="p">,</span> <span class="n">outputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        
        <span class="k">let</span> <span class="nv">button</span> <span class="o">=</span> <span class="kt">UIButton</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">roundedRect</span><span class="p">)</span>
        <span class="n">button</span><span class="o">.</span><span class="nf">setTitle</span><span class="p">(</span><span class="s">"Start"</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">normal</span><span class="p">])</span>
        <span class="n">button</span><span class="o">.</span><span class="nf">addTarget</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="err">#</span><span class="nf">selector</span><span class="p">(</span><span class="n">doStart</span><span class="p">),</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">touchUpInside</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="n">button</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">doStart</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">outputObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="o">.</span><span class="n">tappedStart</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>A few small changes:</p>

<ul>
  <li>We’ve added a new output case <code class="highlighter-rouge">tappedStart</code>.</li>
  <li>We’ve added a button with a standard target/selector.</li>
  <li>We’re sending <code class="highlighter-rouge">Outputs.tappedStart</code> to the private <code class="highlighter-rouge">outputObserver</code> on each button tap.</li>
</ul>

<p>The outside world can subscribe to <code class="highlighter-rouge">outputSignal</code> on this view controller and respond to the single event type <code class="highlighter-rouge">tappedStart</code>.</p>

<blockquote>
  <p>For now, I’m going to continue using the grammar <code class="highlighter-rouge">tap</code> for view controller outputs (sending them “as is” so to speak) and allowing subscribers translate the meaning. In the future, I’ll probably revisit this decision.</p>
</blockquote>

<h4 id="static-input-two-buttons-two-outputs">Static input, two buttons, two outputs</h4>

<p>Let’s try something more useful. Now the view controller will accept a static list of pizza toppings, and broadcast the ones the user chose or allow the user to cancel.</p>

<div class="caption-wrapper"><img class="caption" src="/images/stateless_coordinators-02.jpg" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">PizzaTopping</span> <span class="o">=</span> <span class="kt">String</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">SelectToppingsViewController</span><span class="p">:</span> <span class="kt">UITableViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Inputs</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">tapCancel</span>
        <span class="k">case</span> <span class="nf">selectToppings</span><span class="p">([</span><span class="kt">PizzaTopping</span><span class="p">])</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">inputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">inputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="k">let</span> <span class="nv">outputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">outputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="k">let</span> <span class="nv">toppings</span><span class="p">:</span> <span class="p">[</span><span class="kt">PizzaTopping</span><span class="p">]</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">toppings</span><span class="p">:</span> <span class="p">[</span><span class="kt">PizzaTopping</span><span class="p">])</span> <span class="p">{</span>
        
        <span class="k">self</span><span class="o">.</span><span class="n">toppings</span> <span class="o">=</span> <span class="nf">toppings</span>
        
        <span class="p">(</span><span class="n">inputSignal</span><span class="p">,</span> <span class="n">inputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        <span class="p">(</span><span class="n">outputSignal</span><span class="p">,</span> <span class="n">outputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
    
        <span class="n">navigationItem</span><span class="o">.</span><span class="n">leftBarButtonItem</span> <span class="o">=</span> <span class="kt">UIBarButtonItem</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"Cancel"</span><span class="p">,</span> <span class="nv">style</span><span class="p">:</span> <span class="o">.</span><span class="n">plain</span><span class="p">,</span> <span class="nv">target</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="err">#</span><span class="nf">selector</span><span class="p">(</span><span class="n">doCancel</span><span class="p">))</span>
        <span class="n">navigationItem</span><span class="o">.</span><span class="n">rightBarButtonItem</span> <span class="o">=</span> <span class="kt">UIBarButtonItem</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"Next"</span><span class="p">,</span> <span class="nv">style</span><span class="p">:</span> <span class="o">.</span><span class="n">plain</span><span class="p">,</span> <span class="nv">target</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="err">#</span><span class="nf">selector</span><span class="p">(</span><span class="n">doNext</span><span class="p">))</span>
        
        <span class="n">tableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">UITableViewCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>
        <span class="n">tableView</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
        <span class="n">tableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="k">self</span>
        <span class="n">tableView</span><span class="o">.</span><span class="n">allowsMultipleSelection</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">doCancel</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">outputObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="o">.</span><span class="n">tapCancel</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">doNext</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">selectedToppings</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="n">indexPathsForSelectedRows</span><span class="p">?</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">toppings</span><span class="p">[</span><span class="nv">$0</span><span class="o">.</span><span class="n">row</span><span class="p">]</span> <span class="p">}</span> <span class="p">??</span> <span class="p">[]</span>
        <span class="n">outputObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="o">.</span><span class="nf">selectToppings</span><span class="p">(</span><span class="n">selectedToppings</span><span class="p">))</span>
    <span class="p">}</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">toppings</span><span class="o">.</span><span class="n">count</span>
    <span class="p">}</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">.</span><span class="k">self</span><span class="p">),</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">textLabel</span><span class="p">?</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">toppings</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cell</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We’ve added a table view with multiple selection as well as two bar button items. Since our input is static (i.e. the input will not change for the entire lifetime of the view controller), we don’t have to declare it as a part of our signal <code class="highlighter-rouge">Inputs</code>.</p>

<p>Notice we’re sending an associated value <code class="highlighter-rouge">[PizzaToppings]</code>. Another important note is that view controllers should only communicate to the outside world through immutable data structures.</p>

<p>The public API surface of this subclass is:</p>

<ul>
  <li><code class="highlighter-rouge">init(toppings: [PizzaTopping])</code></li>
  <li><code class="highlighter-rouge">outputSignal: Signal&lt;Outputs, NoError&gt;</code></li>
</ul>

<h4 id="cells-with-multiple-buttons">Cells with multiple buttons</h4>

<p>Let’s see how this pattern extends deeper into the view hierarchy by introducing reusable cells with inner buttons.</p>

<blockquote>
  <p>This example isn’t strictly necessary to understand the coordinator section, so feel free to skip it.</p>
</blockquote>

<p>This time we have a view controller that shows a static table of <code class="highlighter-rouge">n</code> tweets, each with a share button and a save button. The outputs available to external classes are <code class="highlighter-rouge">tapSave(Tweet)</code> and <code class="highlighter-rouge">tapShare(Tweet)</code>.</p>

<div class="caption-wrapper"><img class="caption" src="/images/stateless_coordinators-03.jpg" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<blockquote>
  <p>Note: I’ve included only the code necessary to illustrate this technique.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Tweet</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TweetViewModel</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">tapSave</span><span class="p">(</span><span class="kt">Tweet</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">tapShare</span><span class="p">(</span><span class="kt">Tweet</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">let</span> <span class="nv">outputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">outputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="k">let</span> <span class="nv">tweet</span><span class="p">:</span> <span class="kt">Tweet</span>
    <span class="k">let</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">tweet</span><span class="p">:</span> <span class="kt">Tweet</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">outputSignal</span><span class="p">,</span> <span class="n">outputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        <span class="k">self</span><span class="o">.</span><span class="n">tweet</span> <span class="o">=</span> <span class="n">tweet</span>
        <span class="k">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">tweet</span><span class="o">.</span><span class="n">text</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">doTapSave</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">outputObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="o">.</span><span class="nf">tapSave</span><span class="p">(</span><span class="n">tweet</span><span class="p">))</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">doTapShare</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">outputObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="o">.</span><span class="nf">tapShare</span><span class="p">(</span><span class="n">tweet</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TweetCell</span><span class="p">:</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">saveButton</span> <span class="o">=</span> <span class="kt">UIButton</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">system</span><span class="p">)</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">shareButton</span> <span class="o">=</span> <span class="kt">UIButton</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">system</span><span class="p">)</span>

    <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">TweetViewModel</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">viewModel</span><span class="p">?</span><span class="o">.</span><span class="n">text</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">override</span> <span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="kt">UITableViewCellStyle</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="n">style</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="n">reuseIdentifier</span><span class="p">)</span>
        
        <span class="n">shareButton</span><span class="o">.</span><span class="nf">addTarget</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="err">#</span><span class="nf">selector</span><span class="p">(</span><span class="n">doTapSave</span><span class="p">),</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">touchUpInside</span><span class="p">)</span>
        <span class="n">shareButton</span><span class="o">.</span><span class="nf">addTarget</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="err">#</span><span class="nf">selector</span><span class="p">(</span><span class="n">doTapShare</span><span class="p">),</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">touchUpInside</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">doTapSave</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">viewModel</span><span class="p">?</span><span class="o">.</span><span class="nf">doTapSave</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">doTapShare</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">viewModel</span><span class="p">?</span><span class="o">.</span><span class="nf">doTapShare</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TweetsViewController</span><span class="p">:</span> <span class="kt">UITableViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">tapSave</span><span class="p">(</span><span class="kt">Tweet</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">tapShare</span><span class="p">(</span><span class="kt">Tweet</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">let</span> <span class="nv">outputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">outputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="kd">private</span> <span class="nf">let</span> <span class="p">(</span><span class="n">outputBusSignal</span><span class="p">,</span> <span class="n">outputBusObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
    
    <span class="k">let</span> <span class="nv">viewModels</span><span class="p">:</span> <span class="p">[</span><span class="kt">TweetViewModel</span><span class="p">]</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">tweets</span><span class="p">:</span> <span class="p">[</span><span class="kt">Tweet</span><span class="p">])</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">outputSignal</span><span class="p">,</span> <span class="n">outputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Outputs</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        
        <span class="n">outputBusSignal</span><span class="o">.</span><span class="nf">flatten</span><span class="p">(</span><span class="o">.</span><span class="n">merge</span><span class="p">)</span><span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="n">outputObserver</span><span class="p">)</span>
        
        <span class="k">self</span><span class="o">.</span><span class="n">viewModels</span> <span class="o">=</span> <span class="n">tweets</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="p">[</span><span class="k">unowned</span> <span class="n">outputBusObserver</span><span class="p">]</span> <span class="p">(</span><span class="nv">tweet</span><span class="p">:</span> <span class="kt">Tweet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TweetViewModel</span> <span class="k">in</span>
            <span class="k">let</span> <span class="nv">tweetViewModel</span> <span class="o">=</span> <span class="kt">TweetViewModel</span><span class="p">(</span><span class="nv">tweet</span><span class="p">:</span> <span class="n">tweet</span><span class="p">)</span>
            <span class="n">outputBusObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">tweetViewModel</span><span class="o">.</span><span class="n">outputSignal</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">TweetsViewController</span><span class="o">.</span><span class="n">mapIO</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">tweetViewModel</span>
        <span class="p">})</span>
        
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="kt">TweetCell</span><span class="o">.</span><span class="k">self</span><span class="p">),</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as!</span> <span class="kt">TweetCell</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">viewModel</span> <span class="o">=</span> <span class="n">viewModels</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cell</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">mapIO</span><span class="p">(</span><span class="nv">output</span><span class="p">:</span> <span class="kt">TweetViewModel</span><span class="o">.</span><span class="kt">Outputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TweetsViewController</span><span class="o">.</span><span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">output</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">tapSave</span><span class="p">(</span><span class="k">let</span> <span class="nv">tweet</span><span class="p">):</span> <span class="k">return</span> <span class="o">.</span><span class="nf">tapSave</span><span class="p">(</span><span class="n">tweet</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">tapShare</span><span class="p">(</span><span class="k">let</span> <span class="nv">tweet</span><span class="p">):</span> <span class="k">return</span> <span class="o">.</span><span class="nf">tapShare</span><span class="p">(</span><span class="n">tweet</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>I chose to use a dedicated view model for each tweet. It’s possible to use this technique without a view model, but the reuse semantics are a bit different.</p>

<p>You’ll notice <code class="highlighter-rouge">TweetViewModel</code> has a output signal/observer set. When a view model is assigned to a visible cell, a button tap on that cell will be transformed into a <code class="highlighter-rouge">tapShare</code> or <code class="highlighter-rouge">tapSave</code> enum value on the view model’s output signal.</p>

<p>In order to capture those values, we created another signal/observer pair called <code class="highlighter-rouge">outputBusSignal</code>/<code class="highlighter-rouge">outputBusObserver</code>. <code class="highlighter-rouge">outputBusSignal</code> is a signal of signals whose values are merged into our standard <code class="highlighter-rouge">outputSignal</code>.</p>

<p>You might be wondering, why do we need a bus? Instead of:</p>

<p><code class="highlighter-rouge">outputBusObserver.send(value: vm.outputSignal.map(mapIO))</code></p>

<p>Why can’t we just do:</p>

<p><code class="highlighter-rouge">viewModel.outputSignal.map(mapIO).observe(outputObserver)</code></p>

<p>The reason is safety. As the consumer of the view model, we can’t guarantee that <code class="highlighter-rouge">viewModel.outputSignal</code> won’t send a <code class="highlighter-rouge">.completed</code> ReactiveSwift event. If it does, the <code class="highlighter-rouge">.completed</code> event will propagate through and terminate all the downstream signals and no further events can be processed by the system. (This problem could be solved by a specialized reactive framework signal that 1. only sends values and 2. stays alive only as long as it is retained by its owner.)</p>

<p>Therefore another cardinal rule of this architecture while using a value/error/completed reactive framework is <strong>never connect signals directly together</strong>.</p>

<p>Moving on. You’ll also notice the static function <code class="highlighter-rouge">mapIO</code> that transforms the child’s <code class="highlighter-rouge">Outputs</code> type to the parent’s <code class="highlighter-rouge">Outputs</code> type.</p>

<p><code class="highlighter-rouge">static func mapIO(output: TweetViewModel.Outputs) -&gt; TweetsViewController.Outputs</code></p>

<p>In this architecture, you’ll see this function defined on its own very often for the sake of explicitness. In general, this architecture focuses on wiring input and output signals together in various ways, transforming the inner values. I’ve standardized the name as <code class="highlighter-rouge">mapIO</code>. Conveniently, in case your class has to map different output types you can use the same function name. You’ll see more examples in the upcoming coordinators section.</p>

<h4 id="additional-complexity">Additional complexity</h4>

<p>I know I haven’t illustrated more complex cases like using the <code class="highlighter-rouge">Inputs</code> signal of the view controller. At the moment, I have an vague idea of how I’d want to use the <code class="highlighter-rouge">Inputs</code> signal instead of passing in data providers or view models to the view controller. For now though, I’d like to move on to the coordinators to see how we can actually use the standardized <code class="highlighter-rouge">Outputs</code> signal of multiple view controllers to manage our view controller hierarchy from above.</p>

<p>Hopefully, through these examples you’re getting a feel for what we’re trying to accomplish. We’ve created a strict grammar for communication with view layer classes in our architecture (analogous to a protocol) and provided an extension point for coordinators.</p>

<h3 id="coordinator">Coordinator</h3>

<p>I’ll first outline the general shape of a coordinator in this architecture. Then I’ll show implementations of three common view controller paradigms in iOS: modal presentation/dismissing, navigation pushing/popping, and selection by tabs.</p>

<h4 id="basic-template-1">Basic template</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Coordinator</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">vend</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">ViewController</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">viewController</span> <span class="o">=</span> <span class="kt">ViewController</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">viewController</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Coordinators in this architecture are structurally quite simple. A coordinator is a container for static functions, the most important being the <code class="highlighter-rouge">vend</code> function.</p>

<p>Because <code class="highlighter-rouge">vend</code> is a static function, it needs to take in any dependencies required to initialize its view controller. <code class="highlighter-rouge">vend</code> will <em>always</em> return a <code class="highlighter-rouge">UIViewController</code> subclass.</p>

<blockquote>
  <p>Aside: why not make <code class="highlighter-rouge">Coordinator</code> a protocol? <code class="highlighter-rouge">vend</code>’s arguments vary on the type of view controller being created. The type of view controller being returned needs to be knowable by the calling class so that its input and output signals can be properly utilized.</p>
</blockquote>

<p>Because coordinators are simply recipes for creating view controllers and wiring together signals, we don’t need to worry about creating a whole sidecar system that simultaneously owns and takes orders from UIKit. (A lot of the motivation behind this architecture was getting tired of fighting UIKit, but still wanting to improve MVC). View controllers still follow their lifetime semantics when they’re attached to windows and presented by other view controllers. There’s no double referencing or external monitoring of UIKit’s inner workings required. This also means we could add this architecture to an existing architecture simply by vending a new view controller from a coordinator into the existing code.</p>

<p>How we go about working within the UIKit system will be illustrated in the examples to come.</p>

<h4 id="presenting">Presenting</h4>

<p>The most simple case is a view controller that wants to present an error. <code class="highlighter-rouge">UIAlertController</code> handles its own dismissal so at this point we won’t worry about handling output from a presented view controller.</p>

<div class="caption-wrapper"><img class="caption" src="/images/stateless_coordinators-04.jpg" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>(Note: I’ve omitted some code in the sample below).</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">MainViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">error</span><span class="p">(</span><span class="kt">NSError</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">AlertCoordinator</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">vend</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kt">NSError</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UIAlertController</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">alertController</span> <span class="o">=</span> <span class="kt">UIAlertController</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"Error"</span><span class="p">,</span> <span class="nv">message</span><span class="p">:</span> <span class="n">error</span><span class="o">.</span><span class="n">localizedDescription</span><span class="p">,</span> <span class="nv">preferredStyle</span><span class="p">:</span> <span class="o">.</span><span class="n">alert</span><span class="p">)</span>
        <span class="n">alertController</span><span class="o">.</span><span class="nf">addAction</span><span class="p">(</span><span class="kt">UIAlertAction</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"OK"</span><span class="p">,</span> <span class="nv">style</span><span class="p">:</span> <span class="kt">UIAlertActionStyle</span><span class="o">.</span><span class="k">default</span><span class="p">,</span> <span class="nv">handler</span><span class="p">:</span> <span class="kc">nil</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">alertController</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">MainCoordinator</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">vend</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">MainViewController</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">mainViewController</span> <span class="o">=</span> <span class="kt">MainViewController</span><span class="p">()</span>
        
        <span class="n">mainViewController</span><span class="o">.</span><span class="n">outputSignal</span>
            <span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">UIScheduler</span><span class="p">())</span>
            <span class="o">.</span><span class="n">observeValues</span> <span class="p">{</span> <span class="p">[</span><span class="k">unowned</span> <span class="n">mainViewController</span><span class="p">]</span> <span class="p">(</span><span class="nv">output</span><span class="p">:</span> <span class="kt">MainViewController</span><span class="o">.</span><span class="kt">Outputs</span><span class="p">)</span> <span class="k">in</span>
                <span class="k">switch</span> <span class="n">output</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">.</span><span class="nf">error</span><span class="p">(</span><span class="k">let</span> <span class="nv">error</span><span class="p">):</span>
                    <span class="k">let</span> <span class="nv">alertController</span> <span class="o">=</span> <span class="kt">AlertCoordinator</span><span class="o">.</span><span class="nf">vend</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="p">)</span>
                    <span class="n">mainViewController</span><span class="o">.</span><span class="nf">present</span><span class="p">(</span><span class="n">alertController</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nv">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
        <span class="k">return</span> <span class="n">mainViewController</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">AlertCoordinator</code> is as simple as the template. It configures a view controller (in this case, pretty trivially) and returns it. Whether this work can be inlined into the caller depends on how complex the set up is, how often these kinds of view controllers will be created, and your discretion.</p>

<p>In <code class="highlighter-rouge">MainCoordinator</code>, in addition to creating a <code class="highlighter-rouge">MainViewController</code>, we’re attaching an ad-hoc observer to its <code class="highlighter-rouge">outputSignal</code>. We’ll ensure the observe block is executed on the UI thread because we can’t guarantee <code class="highlighter-rouge">outputSignal</code> will always return values on the UI thread.</p>

<p>We have to create a unowned capture block for <code class="highlighter-rouge">mainViewController</code>, otherwise it will create a retain cycle.</p>

<p>We switch on all output types. In this case there’s only one. Personally, I like exhaustive enums and if a view controller added an output type, I would want to ensure it was handled in the coordinator or intentionally discarded.</p>

<p>The caller of <code class="highlighter-rouge">MainCoordinator</code> (and receiver of <code class="highlighter-rouge">MainViewController</code>) could be the our app delegate or a completely separate module of the app.</p>

<p>Because <code class="highlighter-rouge">MainViewController</code> is returned directly from the <code class="highlighter-rouge">vend</code> function, that also means the caller has the ability to attach any number of observers to the public <code class="highlighter-rouge">MainViewController.outputSignal</code>. This functionality may be useful, but you’ll see in the coming examples that navigating in this fashion is relatively rare in data driven apps.</p>

<p>The lifetime of the observe block we created is tied directly to <code class="highlighter-rouge">MainViewController.outputSignal</code> which will be destroyed alongside <code class="highlighter-rouge">MainViewController</code>. <code class="highlighter-rouge">MainCoordinator</code> itself is stateless.</p>

<h4 id="navigation-stack">Navigation stack</h4>

<p>I find that in data driven apps, view controllers are almost always in a navigation stack, and similarly are presenting other navigation stacks. Therefore, I created a helper <code class="highlighter-rouge">UINavigationController</code> subclass for use in coordinators. Let’s take a look at the template for what I call <code class="highlighter-rouge">IONavigationController</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">IONavigationController</span><span class="o">&lt;</span><span class="kt">InputType</span><span class="p">,</span> <span class="kt">OutputType</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">UINavigationController</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">inputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">InputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">inputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">InputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">outputSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">OutputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">outputObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">OutputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">inputBusSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">InputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">inputBusObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">InputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">outputBusSignal</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">OutputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">outputBusObserver</span><span class="p">:</span> <span class="kt">Observer</span><span class="o">&lt;</span><span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">OutputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span>
    
    <span class="k">override</span> <span class="nf">init</span><span class="p">(</span><span class="n">nibName</span> <span class="nv">nibNameOrNil</span><span class="p">:</span> <span class="kt">String</span><span class="p">?,</span> <span class="n">bundle</span> <span class="nv">nibBundleOrNil</span><span class="p">:</span> <span class="kt">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">inputSignal</span><span class="p">,</span> <span class="n">inputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">InputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        <span class="p">(</span><span class="n">outputSignal</span><span class="p">,</span> <span class="n">outputObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">OutputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        <span class="p">(</span><span class="n">inputBusSignal</span><span class="p">,</span> <span class="n">inputBusObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">InputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        <span class="p">(</span><span class="n">outputBusSignal</span><span class="p">,</span> <span class="n">outputBusObserver</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">Signal</span><span class="o">&lt;</span><span class="kt">OutputType</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">NoError</span><span class="o">&gt;.</span><span class="nf">pipe</span><span class="p">()</span>
        
        <span class="n">inputBusSignal</span><span class="o">.</span><span class="nf">flatten</span><span class="p">(</span><span class="o">.</span><span class="n">merge</span><span class="p">)</span><span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="n">inputObserver</span><span class="p">)</span>
        <span class="n">outputBusSignal</span><span class="o">.</span><span class="nf">flatten</span><span class="p">(</span><span class="o">.</span><span class="n">merge</span><span class="p">)</span><span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="n">outputObserver</span><span class="p">)</span>
        
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="n">nibNameOrNil</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="n">nibBundleOrNil</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The purpose of <code class="highlighter-rouge">IONavigationController</code> will be more clear in the coming examples. For now, notice that the input/output signal structure looks similar to our view controllers, except the input and output types are specified by the instantiating coordinator and the basic signal pairs are public.</p>

<h4 id="presenting-and-dismissing">Presenting and dismissing</h4>

<p>Let’s imagine we have an app with a main view controller and a settings view controller, each within a navigation stack. The main view controller presents a settings view controller modally. The settings view controller can be dismissed, but no model data is transferred between the two.</p>

<div class="caption-wrapper"><img class="caption" src="/images/stateless_coordinators-05.jpg" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>I’ll split the code up this time, showing the <code class="highlighter-rouge">SettingsCoordinator</code> components on their own first. (Note: I’ve omitted some code for clarity.)</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">SettingsViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">tapDone</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">SettingsCoordinator</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Inputs</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">done</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">vend</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">IONavigationController</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">Outputs</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">settingsViewController</span> <span class="o">=</span> <span class="kt">SettingsViewController</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">navigationController</span> <span class="o">=</span> <span class="kt">IONavigationController</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">Outputs</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">rootViewController</span><span class="p">:</span> <span class="n">mainViewController</span><span class="p">)</span>
        
        <span class="n">navigationController</span><span class="o">.</span><span class="n">outputBusObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">settingsViewController</span><span class="o">.</span><span class="n">outputSignal</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">mapIO</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">navigationController</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">mapIO</span><span class="p">(</span><span class="nv">output</span><span class="p">:</span> <span class="kt">SettingsViewController</span><span class="o">.</span><span class="kt">Outputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">SettingsCoordinator</span><span class="o">.</span><span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">output</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">tapDone</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">done</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">IONavigationController</code> is essentially a wrapper for <code class="highlighter-rouge">SettingsViewController</code> in this case. This architecture makes it pretty straightforward to forward signals alongside a quick map.</p>

<p>As previously mentioned in the view controllers section, we’re placing <code class="highlighter-rouge">settingsViewController</code>’s mapped <code class="highlighter-rouge">outputSignal</code> on an <code class="highlighter-rouge">outputBusObserver</code> instead of connecting it directly to maintain safety. We shouldn’t assume <code class="highlighter-rouge">settingsViewController.outputSignal</code> will never complete.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// Unsafe</span>
<span class="n">settingsViewController</span><span class="o">.</span><span class="n">outputSignal</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">mapIO</span><span class="p">)</span><span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="n">navigationController</span><span class="o">.</span><span class="n">outputObserver</span><span class="p">)</span>

<span class="c1">// Safe</span>
<span class="n">navigationController</span><span class="o">.</span><span class="n">outputBusObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">settingsViewController</span><span class="o">.</span><span class="n">outputSignal</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">mapIO</span><span class="p">))</span>
</code></pre>
</div>

<p>Now callers of <code class="highlighter-rouge">SettingsCoordinator</code> can interact with the returned <code class="highlighter-rouge">IONavigationController</code> like they do with any other view controller by observing its outputs.</p>

<p>I almost always follow the rule that view controllers should not dismiss themselves, even though UIKit is pretty lax with allowing this behavior (and allowing any view controller to walk the parent/child chain up and down). The reason being that the view controller shouldn’t be aware of its presentation context. That’s why this coordinator returns <code class="highlighter-rouge">done</code> instead of just dismissing itself.</p>

<blockquote>
  <p>At the moment, I haven’t figured out a way to obscure the concrete <code class="highlighter-rouge">IONavigationController</code> behind a protocol when it’s returned from a coordinator’s <code class="highlighter-rouge">vend</code> function. Therefore all its public signals and observers are available down the stack, even though they shouldn’t be.</p>
</blockquote>

<p>Now let’s look at the <code class="highlighter-rouge">MainCoordinator</code> which will be responsible for presenting and dismissing the result of <code class="highlighter-rouge">SettingsCoordinator</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">MainViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">tapSettings</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">MainCoordinator</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Inputs</span> <span class="p">{</span>
        <span class="n">presentSettings</span>
        <span class="n">dismissChild</span>
    <span class="p">}</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span> <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">vend</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">IONavigationController</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">Outputs</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">mainViewController</span> <span class="o">=</span> <span class="kt">MainViewController</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">navigationController</span> <span class="o">=</span> <span class="kt">IONavigationController</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">Outputs</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">rootViewController</span><span class="p">:</span> <span class="n">mainViewController</span><span class="p">)</span>
        
        <span class="n">navigationController</span><span class="o">.</span><span class="n">inputBusObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">mainViewController</span><span class="o">.</span><span class="n">outputSignal</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">mapIO</span><span class="p">))</span>
        
        <span class="n">navigationController</span><span class="o">.</span><span class="n">inputSignal</span>
            <span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">UIScheduler</span><span class="p">())</span>
            <span class="o">.</span><span class="n">observeValues</span> <span class="p">{</span> <span class="p">[</span><span class="k">unowned</span> <span class="n">navigationController</span><span class="p">]</span> <span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">MainCoordinator</span><span class="o">.</span><span class="kt">Inputs</span><span class="p">)</span> <span class="k">in</span>
                <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">.</span><span class="nv">presentSettings</span><span class="p">:</span>
                    <span class="k">let</span> <span class="nv">settingsNavigationController</span> <span class="o">=</span> <span class="kt">SettingsCoordinator</span><span class="o">.</span><span class="nf">vend</span><span class="p">()</span>
                    <span class="n">navigationController</span><span class="o">.</span><span class="n">inputBusObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">settingsNavigationController</span><span class="o">.</span><span class="n">outputObserver</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">mapIO</span><span class="p">))</span>
                    <span class="n">navigationController</span><span class="o">.</span><span class="nf">present</span><span class="p">(</span><span class="n">settingsNavigationController</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nv">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
                <span class="k">case</span> <span class="o">.</span><span class="nv">dismissChild</span><span class="p">:</span>
                    <span class="n">navigationController</span><span class="o">.</span><span class="nf">dismiss</span><span class="p">(</span><span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nv">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">navigationController</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">mapIO</span><span class="p">(</span><span class="nv">output</span><span class="p">:</span> <span class="kt">MainViewController</span><span class="o">.</span><span class="kt">Outputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">MainCoordinator</span><span class="o">.</span><span class="kt">Inputs</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">output</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">tapSettings</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">presentSettings</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">mapIO</span><span class="p">(</span><span class="nv">output</span><span class="p">:</span> <span class="kt">SettingsCoordinator</span><span class="o">.</span><span class="kt">Outputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">MainCoordinator</span><span class="o">.</span><span class="kt">Inputs</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">output</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">done</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">dismissChild</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We’re going to use a new technique since this coordinator is a bit more complicated. We’re going to map all side-effecting actions to specific coordinator <code class="highlighter-rouge">Inputs</code> and map and pipe all output signals from view controllers into <code class="highlighter-rouge">inputObserver</code>/<code class="highlighter-rouge">inputSignal</code>. We’ll declare all the action/data pairs that this coordinator can process as <code class="highlighter-rouge">Inputs</code>.</p>

<blockquote>
  <p>I’m not 100% sold on whether marking internal actions as <code class="highlighter-rouge">Inputs</code> is a sustainable idea. In theory they shouldn’t necessarily be exposed as <code class="highlighter-rouge">Inputs</code>. There should be another internal signal type that handles the primary data processing flows for the coordinator.</p>
</blockquote>

<p>As the <code class="highlighter-rouge">rootViewController</code>, <code class="highlighter-rouge">mainViewController</code> doesn’t need to be initialized within the <code class="highlighter-rouge">inputSignal</code> processing chain. <code class="highlighter-rouge">mainViewController.outputSignal</code> will be mapped and connected to the <code class="highlighter-rouge">IONavigationController</code>’s <code class="highlighter-rouge">inputBusObserver</code>. We’ve seen this pattern a few times already.</p>

<p>Moving into the observe block, we’ll find two cases we need to cover. In general, the code within each case should only be about 3 lines long max like shown in <code class="highlighter-rouge">presentSettings</code>.</p>

<ol>
  <li>Vend a new view controller.</li>
  <li>Connect outputs to inputs.</li>
  <li>Present the view controller.</li>
</ol>

<p>For side effects with no output:</p>

<ol>
  <li>Create a <code class="highlighter-rouge">SignalProducer</code>.</li>
  <li>Start the <code class="highlighter-rouge">SignalProducer</code> and discard the output.</li>
</ol>

<p>For side effects with output:</p>

<ol>
  <li>Create a <code class="highlighter-rouge">SignalProducer</code>.</li>
  <li>Start the <code class="highlighter-rouge">SignalProducer</code>.</li>
  <li>Wire the <code class="highlighter-rouge">SignalProducer</code>’s resulting <code class="highlighter-rouge">Signal</code> to the navigation controller’s input bus.</li>
</ol>

<h4 id="pushing-and-popping">Pushing and popping</h4>

<p>To demonstrate pushing and popping with a navigation controller, let’s look at an “infinite pushing” interface with a simplified version of Twitter.</p>

<p>In this version we have a root view controller that shows tweets on your timeline. From here, you can tap on any tweet or user to view to push the tweet detail view controller or user view controller, respectively. From the user view controller you can view any of that user’s tweets in a detail view. From the tweet detail view controller you can view the details of any other tweet in the replies, view any user profile listed in the replies, or perform a secret gesture to pop back to your timeline.</p>

<div class="caption-wrapper"><img class="caption" src="/images/stateless_coordinators-06.jpg" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>(Note: some structural code has been omitted for clarity. Data fetching code has also been omitted.)</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Tweet</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">struct</span> <span class="kt">User</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TweetsViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">tapTweet</span><span class="p">(</span><span class="kt">Tweet</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">tapUser</span><span class="p">(</span><span class="kt">User</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TweetDetailViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">tapTweet</span><span class="p">(</span><span class="kt">Tweet</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">tapUser</span><span class="p">(</span><span class="kt">User</span><span class="p">)</span>
        <span class="k">case</span> <span class="n">secretPopInitiated</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">UserViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">tapTweet</span><span class="p">(</span><span class="kt">Tweet</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">TimelineCoordinator</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Inputs</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">presentTweetDetail</span><span class="p">(</span><span class="kt">Tweet</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">presentUser</span><span class="p">(</span><span class="kt">User</span><span class="p">)</span>
        <span class="k">case</span> <span class="n">popToRoot</span>
    <span class="p">}</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span> <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">vend</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">IONavigationController</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">Outputs</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">tweetsViewController</span> <span class="o">=</span> <span class="kt">TweetsViewController</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">navigationController</span> <span class="o">=</span> <span class="kt">IONavigationController</span><span class="o">&lt;</span><span class="kt">Inputs</span><span class="p">,</span> <span class="kt">Outputs</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">rootViewController</span><span class="p">:</span> <span class="n">tweetsViewController</span><span class="p">)</span>
        
        <span class="n">navigationController</span><span class="o">.</span><span class="n">inputBusObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">tweetsViewController</span><span class="o">.</span><span class="n">outputSignal</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">mapIO</span><span class="p">))</span>
        
        <span class="n">navigationController</span><span class="o">.</span><span class="n">inputSignal</span>
            <span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">UIScheduler</span><span class="p">())</span>
            <span class="o">.</span><span class="n">observeValues</span> <span class="p">{</span> <span class="p">[</span><span class="k">unowned</span> <span class="n">navigationController</span><span class="p">]</span> <span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">TimelineCoordinator</span><span class="o">.</span><span class="kt">Inputs</span><span class="p">)</span> <span class="k">in</span>
                <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">.</span><span class="nf">presentTweetDetail</span><span class="p">(</span><span class="k">let</span> <span class="nv">tweet</span><span class="p">):</span>
                    <span class="k">let</span> <span class="nv">tweetDetailViewController</span> <span class="o">=</span> <span class="kt">TweetDetailViewController</span><span class="p">()</span>
                    <span class="n">navigationController</span><span class="o">.</span><span class="n">inputBusObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">tweetDetailViewController</span><span class="o">.</span><span class="n">outputObserver</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">mapIO</span><span class="p">))</span>
                    <span class="n">navigationController</span><span class="o">.</span><span class="nf">pushViewController</span><span class="p">(</span><span class="n">tweetDetailViewController</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
                <span class="k">case</span> <span class="o">.</span><span class="nf">presentUser</span><span class="p">(</span><span class="k">let</span> <span class="nv">user</span><span class="p">):</span>
                    <span class="k">let</span> <span class="nv">userViewController</span> <span class="o">=</span> <span class="kt">UserViewController</span><span class="p">()</span>
                    <span class="n">navigationController</span><span class="o">.</span><span class="n">inputBusObserver</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">userViewController</span><span class="o">.</span><span class="n">outputObserver</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">mapIO</span><span class="p">))</span>
                    <span class="n">navigationController</span><span class="o">.</span><span class="nf">pushViewController</span><span class="p">(</span><span class="n">userViewController</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
                <span class="k">case</span> <span class="o">.</span><span class="nv">popToRoot</span><span class="p">:</span>
                    <span class="n">navigationController</span><span class="o">.</span><span class="nf">popToRootViewController</span><span class="p">(</span><span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">navigationController</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">mapIO</span><span class="p">(</span><span class="nv">output</span><span class="p">:</span> <span class="kt">TweetsViewController</span><span class="o">.</span><span class="kt">Outputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TimelineCoordinator</span><span class="o">.</span><span class="kt">Inputs</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">output</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">tapTweet</span><span class="p">(</span><span class="k">let</span> <span class="nv">tweet</span><span class="p">):</span> <span class="k">return</span> <span class="o">.</span><span class="nf">presentTweetDetail</span><span class="p">(</span><span class="n">tweet</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">tapUser</span><span class="p">(</span><span class="k">let</span> <span class="nv">user</span><span class="p">):</span> <span class="k">return</span> <span class="o">.</span><span class="nf">presentUser</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">mapIO</span><span class="p">(</span><span class="nv">output</span><span class="p">:</span> <span class="kt">TweetDetailViewController</span><span class="o">.</span><span class="kt">Outputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TimelineCoordinator</span><span class="o">.</span><span class="kt">Inputs</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">output</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">tapTweet</span><span class="p">(</span><span class="k">let</span> <span class="nv">tweet</span><span class="p">):</span> <span class="k">return</span> <span class="o">.</span><span class="nf">presentTweetDetail</span><span class="p">(</span><span class="n">tweet</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">tapUser</span><span class="p">(</span><span class="k">let</span> <span class="nv">user</span><span class="p">):</span> <span class="k">return</span> <span class="o">.</span><span class="nf">presentUser</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">secretPopInitiated</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">popToRoot</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">mapIO</span><span class="p">(</span><span class="nv">output</span><span class="p">:</span> <span class="kt">UserViewController</span><span class="o">.</span><span class="kt">Outputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TimelineCoordinator</span><span class="o">.</span><span class="kt">Inputs</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">output</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">tapTweet</span><span class="p">(</span><span class="k">let</span> <span class="nv">tweet</span><span class="p">):</span> <span class="k">return</span> <span class="o">.</span><span class="nf">presentTweetDetail</span><span class="p">(</span><span class="n">tweet</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>UIKit will handle the standard back behavior automatically for us.</p>

<p>Besides that, this code follows the same patterns as before.</p>

<h4 id="tabbar-interface">TabBar interface</h4>

<p>If none of the view controllers contained by the tab bar view controller pass data or otherwise need to interact, our tab bar coordinator is as straightforward as it usually is with UIKit.</p>

<div class="caption-wrapper"><img class="caption" src="/images/stateless_coordinators-07.jpg" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">MainTabBarCoordinator</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Inputs</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kd">enum</span> <span class="kt">Outputs</span> <span class="p">{</span> <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">vend</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UITabBarController</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">tabBarController</span> <span class="o">=</span> <span class="kt">UITabBarController</span><span class="p">()</span>
        
        <span class="k">let</span> <span class="nv">timelineNavigationController</span> <span class="o">=</span> <span class="kt">TimelineCoordinator</span><span class="o">.</span><span class="nf">vend</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">notificationsNavigationController</span> <span class="o">=</span> <span class="kt">NotificationsCoordinator</span><span class="o">.</span><span class="nf">vend</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">profileNavigationController</span> <span class="o">=</span> <span class="kt">ProfileCoordinator</span><span class="o">.</span><span class="nf">vend</span><span class="p">()</span>
        
        <span class="k">let</span> <span class="nv">viewControllers</span> <span class="o">=</span> <span class="p">[</span><span class="n">timelineNavigationController</span><span class="p">,</span> <span class="n">notificationsNavigationController</span><span class="p">,</span> <span class="n">profileNavigationController</span><span class="p">]</span>
        
        <span class="n">tabBarController</span><span class="o">.</span><span class="nf">setViewControllers</span><span class="p">(</span><span class="n">viewControllers</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">tabBarController</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Each of the navigation controllers vended by the coordinators will handle its own stack transparently.</p>

<p>In the more complicated (and usual) case that our child view controllers have outputs, we should use a <code class="highlighter-rouge">UITabBarController</code> subclass identical to the <code class="highlighter-rouge">UINavigationController</code> subclass <code class="highlighter-rouge">IONavigationController</code> shown previously in this post. The layout of the coordinator will look similar to the <code class="highlighter-rouge">NavigationCoordinator</code>s also presented previously. The primary differences will be that all the view controllers will be created up front (and not in response to another view controller’s output), and all view controller output signals can be wired up at the same time.</p>

<h3 id="code-example-wrap-up">Code example wrap up</h3>

<p>We looked at a fair amount of code.</p>

<p>First, we looked at view controllers in the context of this architecture pattern.</p>

<p>The standard pattern for view controllers is:</p>

<ul>
  <li>Declare an enum of <code class="highlighter-rouge">Inputs</code> and <code class="highlighter-rouge">Outputs</code>.</li>
  <li>Declare a public input observer and a public output signal to accept and transmit dynamic events during the view controller’s lifecycle.</li>
  <li>Accept static dependencies in the initializer.</li>
</ul>

<p>Next, we looked at stateless coordinators in the context of this architecture pattern.</p>

<p>The standard pattern for coordinators is:</p>

<ul>
  <li>Identify as a struct with no state or static methods.</li>
  <li>Declare an enum of <code class="highlighter-rouge">Inputs</code> and <code class="highlighter-rouge">Outputs</code> if necessary.</li>
  <li>Declare a static function called <code class="highlighter-rouge">vend</code> that returns a <code class="highlighter-rouge">UIViewController</code> subclass.</li>
  <li>Accept static dependencies necessary for creating child view controllers in the initializer for <code class="highlighter-rouge">vend</code>.</li>
  <li>Declare pure transformation functions between child view controller outputs and coordinator inputs.</li>
  <li>Dynamically attach child view controller outputs to coordinator inputs.</li>
  <li>Perform navigation related side effects or other side effects.</li>
</ul>

<p>I left out a few relevant code examples for this post. One example I’d like to tackle in the future is using a navigation controller as a “builder” of intermediate steps. The navigation patterns presented above can’t carry state between intermediate steps without passing <em>all</em> information to each step.</p>

<h2 id="unique-attributes">Unique attributes</h2>

<p>This architecture has few unique attributes.</p>

<h3 id="inputoutput-enum-for-specifying-boundaries">Input/Output enum for specifying boundaries</h3>

<p>Enums are one of my favorite features of Swift. I like the exactness of being able to specify “this data can only be one of the these <em>n</em> types” and knowing the compiler will tell me if I’ve forgotten any.</p>

<p>I understand that enums can be a sign of brittleness or tight coupling. However, in the context of this architecture, I consider enums to be a useful building block.</p>

<h3 id="signals-as-the-facilitators-of-state">Signals as the facilitators of state</h3>

<p>There are plenty of posts about the positives of reactive programming. I’ll mention the clean concurrency model, multi-observer support, and composability.</p>

<h3 id="embracing-using-signalobserver-pairs-directly">Embracing using signal/observer pairs directly</h3>

<p>In this architecture, I’ve embraced the imperativeness of UIKit. Using signal/observer pairs blurs the line between reactive and imperative, and is usually seen as a bad thing in the reactive world. In this architecture, I wanted to see if I could supplement UIKit with the most basic building blocks of reactive frameworks.</p>

<h2 id="open-questions">Open questions</h2>

<h3 id="stateful-navigation-flows">Stateful navigation flows</h3>

<p>As mentioned above, I haven’t yet developed a pattern for implementing stateful navigation flows, specifically collecting and combining data from multiple view controllers to produce one output. I need to spend some time considering ways to implement this.</p>

<h3 id="uikit-as-just-another-framework">UIKit as just another framework</h3>

<p>As opposed to Soroush’s coordinator implementation, this architecture still lets UIKit run the show with regards to object lifetimes. I’d like to explore the implications of this in more settings. Are there cases where I’m reliant on UIKit lifetime events in a way that’s detrimental to the user experience? Are there other cases where wrestling control away from UIKit provides additional benefits that I’m not thinking of at the moment?</p>

<h3 id="more-than-just-navigation">More than just navigation</h3>

<p>I’ve intentionally ignored the architecture of data flows beyond saying “data sources can be provided via dependency injection”. In the practice of using this architecture so far I’ve used a few different architectures, the most common being a more looser form of MVVM. I’m still creating a view model for each view controller, but that view model is more or less a helper class of the view controller and the view controller is responsible for communicating with the rest of the app.</p>

<p>I’d like to explore using the <code class="highlighter-rouge">Inputs</code> signal as the only conduit for dynamic communication into a view controller. Does that increase or decrease complexity? Do view controller lifetime events clutter up the communication channels? Does stricter separation push too much responsibility into the coordinator?</p>

<p>What about having both the view controller and the view model have input and output signals and having the coordinator tie them together?</p>

<h3 id="a-specialized-reactive-framework">A specialized reactive framework?</h3>

<p>Using ReactiveSwift for the plumbing of this architecture provides the benefits of interoperability with the rest of the app and usage of the many built in tools maintained so diligently by the community. However, this architecture has the very specific requirement of:</p>

<ul>
  <li>Signal lifetime directly tied to its owner (no termination events).</li>
  <li>0 or more values sent.</li>
  <li>No errors.</li>
</ul>

<p>It’s certainly not worth investing time in creating a new framework at this point (although I technically started exploring <a href="https://github.com/twocentstudios/CircuitMVVM">something similar</a> last year). But at some point it would be interesting to see if the code would be any cleaner and if interoperability could be achieved.</p>

<h3 id="dont-use-ionavigationcontroller-uinavigationcontroller-subclass">Don’t use IONavigationController (UINavigationController subclass)</h3>

<p>It’s convenient to use configure an <code class="highlighter-rouge">IONavigationController</code> from coordinators, but perhaps it would make more sense to create special purpose <code class="highlighter-rouge">UINavigationController</code> subclasses for each coordinator (that also might solve the stateless navigation problem mentioned above).</p>

<h3 id="is-it-really-worth-it-not-to-use-delegation">Is it really worth it not to use delegation?</h3>

<p>Is using an <code class="highlighter-rouge">Outputs</code> enum and a signal really any better than using a protocol and assigning a delegate? I’d like to find more direct comparisons between the two approaches.</p>

<h3 id="all-around-naming">All around naming</h3>

<p>Should view controllers interpret meaning in their events before sending them? Should we keep using UI focused prefixes like “tap” in the <code class="highlighter-rouge">Outputs</code> cases? Should the enums be called <code class="highlighter-rouge">Input</code>/<code class="highlighter-rouge">Output</code> or <code class="highlighter-rouge">Inputs</code>/<code class="highlighter-rouge">Outputs</code>?</p>

<p>Should these coordinators be called something else?</p>

<p>How about <code class="highlighter-rouge">IONavigationController</code>’s <code class="highlighter-rouge">Inputs</code>? Should there be another private enum and signal?</p>

<h3 id="blocks-instead-of-signals">Blocks instead of signals?</h3>

<p>Would it be possible to replace <code class="highlighter-rouge">inputSignal</code>/<code class="highlighter-rouge">outputSignal</code> with an optional <code class="highlighter-rouge">inputBlock?</code>/<code class="highlighter-rouge">outputBlock?</code>? If we’re not using the multi-observer functionality, it could decrease complexity. It would definitely change the all-around syntax of the architecture.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I’ve proposed an architecture for controlling application flow in a UIKit-based iOS app using stateless coordinators.</p>

<p>I’m going to continue working on this architecture in an app (that I may eventually open source) and see if any new patterns emerge. I want to treat this post as a checkpoint and clarify my thinking.</p>

<p>Thanks for reading, and please let me know your thoughts and suggestions. I’m <a href="https://twitter.com/twocentstudios">@twocentstudios</a> on Twitter.</p>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">twocentstudios</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:chris@twocentstudios.com">chris@twocentstudios.com</a></li>
          
          <li>
            <a href="https://github.com/twocentstudios">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/twocentstudios">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          
        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-10207350-4']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



</html>
