<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Modeling View State</title>
  <meta name="description" content="In this post weâ€™ll take a look at techniques to model view state in Swift. The goal of this post is to show how weâ€™d go about translating a mockup like the o...">

  <link href='https://fonts.googleapis.com/css2?family=Work+Sans:wght@300;350;400;600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://twocentstudios.com/2017/07/24/modeling-view-state/">
  <link rel="alternate" type="application/rss+xml" title="twocentstudios" href="http://twocentstudios.com/feed.xml" />
</head>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NE82N02W8S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NE82N02W8S');
</script>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">twocentstudios</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/blog/">Blog</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/portfolio/">Portfolio</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Modeling View State</h1>
    <p class="post-meta">Jul 24, 2017</p>
  </header>

  <article class="post-content">
    <p>In this post weâ€™ll take a look at techniques to model view state in Swift. The goal of this post is to show how weâ€™d go about translating a mockup like the one weâ€™d receive from a designer and convert it into a set of inert view models that fully describe all possible states of our view, but without referencing <code class="language-plaintext highlighter-rouge">UIKit</code>.</p>

<p>In subsequent posts, weâ€™ll look at techniques to transition from one view state to another, ways to create an interactor to orchestrate this process over time, and finally how to consume this view model in a view controller.</p>

<h2 id="background">Background</h2>

<p>In many common architectures, the only way to determine the current state of a view is to query individual properties of <code class="language-plaintext highlighter-rouge">UIView</code> subclasses or visually inspect the final rendering of a view snapshot. Transitions between view states are handled on an ad-hoc basis or the previous view state is simply ignored. Testing is either ignored or implemented with complicated UI-based tooling.</p>

<p>Our goal with this technique is to have a full representation of all view states as a simple data structure in a separate conceptual layer from our UI.</p>

<p>The pros of this technique:</p>

<ul>
  <li>Easier to manage secondary view states like loading, error, and empty.</li>
  <li>Testing is less complicated, and tests run faster.</li>
  <li>Modularization: itâ€™s easier to compose interactors and view models.</li>
  <li>Fewer bugs related to bad view state.</li>
</ul>

<p>The cons of this technique:</p>

<ul>
  <li>Significantly more code.</li>
  <li>All edge cases must be handled explicitly.</li>
  <li>More upfront planning.</li>
  <li>More code must be changed if the design changes.</li>
</ul>

<h2 id="example">Example</h2>

<p>In order to illustrate this technique, weâ€™ll be working through the user profile screen of a fictional social media app I just threw together. Any mockups you receive will probably look a lot nicer than this one ðŸ˜‰.</p>

<h2 id="version-0">Version 0</h2>

<p>In this weekâ€™s sprint, weâ€™ve been asked to implement a simple user profile screen. It wonâ€™t have all the bells and whistles yet. Our product manager has decided to push those to version 2.</p>

<p>Our designer has sent us an initial mockup:</p>

<div class="caption-wrapper"><img class="caption" src="/images/modeling_view_state-01.png" width="250" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>Without much thought we get started with our implementation.</p>

<p>Letâ€™s say our models were previously specified by the backend engineers.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">let</span> <span class="nv">avatarURL</span><span class="p">:</span> <span class="kt">URL</span>
    <span class="k">let</span> <span class="nv">username</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">friendsCount</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">let</span> <span class="nv">location</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">website</span><span class="p">:</span> <span class="kt">URL</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Based on the mockup, our view model is pretty straightforward. Just a little transformation for <code class="language-plaintext highlighter-rouge">friendsCount</code> and <code class="language-plaintext highlighter-rouge">website</code>.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// V0</span>
<span class="kd">struct</span> <span class="kt">UserViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">avatarURL</span><span class="p">:</span> <span class="kt">URL</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">username</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">friendsCount</span><span class="p">:</span> <span class="kt">NSAttributedString</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">location</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">website</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Note that these properties are all optional. This decision is somewhat of a judgement call, but since the properties weâ€™ll be setting on the <code class="language-plaintext highlighter-rouge">UIKit</code> views are optional, it makes sense that we may want to distinguish between a <code class="language-plaintext highlighter-rouge">none</code> value and an empty value.</p>

<p>The V0 view model above is generally where most of us would start coding up view controllers. However, weâ€™d soon realize that weâ€™re missing a few view states.</p>

<h2 id="version-1">Version 1</h2>

<p>Weâ€™ve realized that user profile data is loaded asynchronously from the server, so we request a loading state mockup as well. Our designer obliges:</p>

<div class="caption-wrapper"><img class="caption" src="/images/modeling_view_state-02.png" width="250" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>In this simple case, our designer thinks itâ€™s fine to block the whole screen until the data has been loaded. We could probably optimize this, but weâ€™ll let it go for version 1.</p>

<p>We also inform our designer that our customers may encounter network errors and we should give them the option to retry loading.</p>

<div class="caption-wrapper"><img class="caption" src="/images/modeling_view_state-03.png" width="250" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>Our designer provided a fine looking error state for the profile, but thereâ€™s one more state we need. Our profile screen actually has a state before weâ€™ve started our initial load.</p>

<div class="caption-wrapper"><img class="caption" src="/images/modeling_view_state-04.png" width="250" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>And with that last screen, weâ€™ve covered all the cases we need for V1.</p>

<div class="caption-wrapper"><img class="caption" src="/images/modeling_view_state-05.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>We can now start modeling the rest of our view state, confident that our users will have a better experience if they have a slow or spotty data connection.</p>

<p>The responsibility of our view model is to transform model data into a representation that is immediately consumable by objects in the view layer with very little further transformation. In practice, this is more art than science so-to-speak. There are many correct solutions. View model design can still be heavily reliant on the specifics of how we decide to implement the view layer, e.g. using a <code class="language-plaintext highlighter-rouge">UITableView</code> versus using normal <code class="language-plaintext highlighter-rouge">UIView</code>s and a <code class="language-plaintext highlighter-rouge">UIScrollView</code>.</p>

<p>Based on the current mockup, Iâ€™m going to implement the view layer without a <code class="language-plaintext highlighter-rouge">UITableView</code> since the identity and location of views is known at compile time. To implement the loading and error states, Iâ€™ll add a full screen error view and loading view to the view hierarchy and toggle their hidden states.</p>

<p>The output properties for our view model will now be the following:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// V1 - only outputs</span>
<span class="kd">struct</span> <span class="kt">UserViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">avatarURL</span><span class="p">:</span> <span class="kt">URL</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">username</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">friendsCount</span><span class="p">:</span> <span class="kt">NSAttributedString</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">location</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">website</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    
    <span class="k">let</span> <span class="nv">isHidden</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">LoadingViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">isHidden</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ErrorViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">message</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">actionTitle</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    
    <span class="k">let</span> <span class="nv">isHidden</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ProfileViewModel</span> <span class="p">{</span>    
    <span class="k">let</span> <span class="nv">userViewModel</span><span class="p">:</span> <span class="kt">UserViewModel</span>
    <span class="k">let</span> <span class="nv">loadingViewModel</span><span class="p">:</span> <span class="kt">LoadingViewModel</span>
    <span class="k">let</span> <span class="nv">errorViewModel</span><span class="p">:</span> <span class="kt">ErrorViewModel</span>    
<span class="p">}</span>
</code></pre>
</div>

<p>Since weâ€™re going to have three distinct subviews (user, loading, and error), weâ€™ll create a separate view model for each. Weâ€™ve also added a <code class="language-plaintext highlighter-rouge">isHidden</code> property to <code class="language-plaintext highlighter-rouge">UserViewModel</code> for the <code class="language-plaintext highlighter-rouge">initialized</code> state before <code class="language-plaintext highlighter-rouge">loading</code> begins.</p>

<p>On every view state change, we can set all the properties on all our views. The view layer wonâ€™t need to ensure its states are consistent. That responsibility resides in the view model and can be tested independently.</p>

<p>Now that weâ€™ve determined the outputs that our views need, letâ€™s go back and figure out the inputs and internal state we need to determine those outputs.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// V1 - inputs and outputs</span>
<span class="kd">struct</span> <span class="kt">UserViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">avatarURL</span><span class="p">:</span> <span class="kt">URL</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">username</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">friendsCount</span><span class="p">:</span> <span class="kt">NSAttributedString</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">location</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">website</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    
    <span class="k">let</span> <span class="nv">isHidden</span><span class="p">:</span> <span class="kt">Bool</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="kt">User</span><span class="p">?)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ErrorViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">message</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">actionTitle</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    
    <span class="k">let</span> <span class="nv">isHidden</span><span class="p">:</span> <span class="kt">Bool</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">?)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">LoadingViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">isHidden</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ProfileViewModel</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">initialized</span>
        <span class="k">case</span> <span class="n">loading</span>
        <span class="k">case</span> <span class="nf">loaded</span><span class="p">(</span><span class="kt">User</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">failed</span><span class="p">(</span><span class="kt">Error</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">let</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">State</span>
    
    <span class="k">let</span> <span class="nv">userViewModel</span><span class="p">:</span> <span class="kt">UserViewModel</span>
    <span class="k">let</span> <span class="nv">loadingViewModel</span><span class="p">:</span> <span class="kt">LoadingViewModel</span>
    <span class="k">let</span> <span class="nv">errorViewModel</span><span class="p">:</span> <span class="kt">ErrorViewModel</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        
        <span class="k">switch</span> <span class="n">state</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">initialized</span><span class="p">:</span>
            <span class="k">self</span><span class="o">.</span><span class="n">userViewModel</span> <span class="o">=</span> <span class="kt">UserViewModel</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">loadingViewModel</span> <span class="o">=</span> <span class="kt">LoadingViewModel</span><span class="p">(</span><span class="nv">isHidden</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">errorViewModel</span> <span class="o">=</span> <span class="kt">ErrorViewModel</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">loading</span><span class="p">:</span>
            <span class="k">self</span><span class="o">.</span><span class="n">userViewModel</span> <span class="o">=</span> <span class="kt">UserViewModel</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">loadingViewModel</span> <span class="o">=</span> <span class="kt">LoadingViewModel</span><span class="p">(</span><span class="nv">isHidden</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">errorViewModel</span> <span class="o">=</span> <span class="kt">ErrorViewModel</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">loaded</span><span class="p">(</span><span class="k">let</span> <span class="nv">user</span><span class="p">):</span>
            <span class="k">self</span><span class="o">.</span><span class="n">userViewModel</span> <span class="o">=</span> <span class="kt">UserViewModel</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="n">user</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">loadingViewModel</span> <span class="o">=</span> <span class="kt">LoadingViewModel</span><span class="p">(</span><span class="nv">isHidden</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">errorViewModel</span> <span class="o">=</span> <span class="kt">ErrorViewModel</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">failed</span><span class="p">(</span><span class="k">let</span> <span class="nv">error</span><span class="p">):</span>
            <span class="k">self</span><span class="o">.</span><span class="n">userViewModel</span> <span class="o">=</span> <span class="kt">UserViewModel</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">loadingViewModel</span> <span class="o">=</span> <span class="kt">LoadingViewModel</span><span class="p">(</span><span class="nv">isHidden</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">errorViewModel</span> <span class="o">=</span> <span class="kt">ErrorViewModel</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The three inner view models (<code class="language-plaintext highlighter-rouge">UserViewModel</code>, <code class="language-plaintext highlighter-rouge">LoadingViewModel</code>, <code class="language-plaintext highlighter-rouge">ErrorViewModel</code>) are initialized with an optional model object (Iâ€™ve elided their implementations).</p>

<p>The primary view model (<code class="language-plaintext highlighter-rouge">ProfileViewModel</code>) is initialized with an enum <code class="language-plaintext highlighter-rouge">State</code>, with each case representing one state from our designerâ€™s mockup.</p>

<p>Within the initializer, we map each state to a fully configured set of outputs. A different object will be responsible for initializing <code class="language-plaintext highlighter-rouge">ProfileViewModel</code> and determining valid state changes.</p>

<p>With that, we now have a fully specified view model. Weâ€™ll also have a very light view controller since all we have to do is assign all relevant properties directly whenever the view state changes. (As previously mentioned, weâ€™ll discuss the rest of the implementation of this system in subsequent posts).</p>

<h2 id="version-2">Version 2</h2>

<p>Version 1 has been released into the wild and now our product manager wants to add the userâ€™s posts to their profile screen.</p>

<p>After some planning with design and our backend team, itâ€™s been decided that user profile data and user post data will come from separate API endpoints. Since weâ€™re a relatively new service, we wonâ€™t worry about paging yet (Iâ€™d like to cover paging in a future blog post).</p>

<p>Our product manager and designer have also determined that theyâ€™d like a prettier loading state for the user attributes. (Our designer has also preemptively mocked up all the required states for us).</p>

<div class="caption-wrapper"><img class="caption" src="/images/modeling_view_state-06.png" width="" height="" alt="" title="" /><div class="caption-text"></div></div>

<p>Letâ€™s enumerate the changes weâ€™ll have to make to the view models:</p>

<ul>
  <li>Since our view now includes an indeterminate amount of posts, weâ€™ll convert our view layer to use a <code class="language-plaintext highlighter-rouge">UITableView</code> or <code class="language-plaintext highlighter-rouge">UICollectionView</code> instead of a static view.</li>
  <li>That means we should split up our header view into multiple cells.</li>
  <li>Weâ€™ll need to make a new shimmering <code class="language-plaintext highlighter-rouge">UILabel</code> class for displaying <code class="language-plaintext highlighter-rouge">initialized</code>, <code class="language-plaintext highlighter-rouge">loading</code>, and <code class="language-plaintext highlighter-rouge">loaded</code> states.</li>
  <li>We have two independent view states (profile and posts). We should model these separately and compose them.</li>
</ul>

<p>Letâ€™s start by creating the smallest building blocks.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// V2 - building blocks</span>
<span class="kd">struct</span> <span class="kt">ErrorViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">message</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">actionTitle</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">LoadingTextViewModel</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">initialized</span>
        <span class="k">case</span> <span class="n">loading</span>
        <span class="k">case</span> <span class="nf">loaded</span><span class="p">(</span><span class="kt">NSAttributedString</span><span class="p">?)</span>
    <span class="p">}</span>
    
    <span class="k">let</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">State</span>
          
    <span class="k">let</span> <span class="nv">isLoading</span><span class="p">:</span> <span class="kt">Bool</span>
    <span class="k">let</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">NSAttributedString</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ProfileHeaderViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">avatarURL</span><span class="p">:</span> <span class="kt">URL</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">username</span><span class="p">:</span> <span class="kt">LoadingTextViewModel</span>
    <span class="k">let</span> <span class="nv">friendsCount</span><span class="p">:</span> <span class="kt">LoadingTextViewModel</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ProfileAttributeViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Post</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">let</span> <span class="nv">date</span><span class="p">:</span> <span class="kt">Date</span>
    <span class="k">let</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">PostViewModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">date</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Each of the above will map 1-to-1 with a cell, except for <code class="language-plaintext highlighter-rouge">LoadingTextViewModel</code>.</p>

<p>We can compose the above view models into the view models for profile and posts.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// V2 - component view models</span>
<span class="kd">struct</span> <span class="kt">ProfileViewModel</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">initialized</span>
        <span class="k">case</span> <span class="n">loading</span>
        <span class="k">case</span> <span class="nf">loaded</span><span class="p">(</span><span class="kt">User</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">failed</span><span class="p">(</span><span class="kt">Error</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">enum</span> <span class="kt">ViewModelType</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">header</span><span class="p">(</span><span class="kt">ProfileHeaderViewModel</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">attribute</span><span class="p">(</span><span class="kt">ProfileAttributeViewModel</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">error</span><span class="p">(</span><span class="kt">ErrorViewModel</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">let</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">State</span>
    
    <span class="k">let</span> <span class="nv">viewModels</span><span class="p">:</span> <span class="p">[</span><span class="kt">ViewModelType</span><span class="p">]</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">struct</span> <span class="kt">PostsViewModel</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">initialized</span>
        <span class="k">case</span> <span class="n">loading</span>
        <span class="k">case</span> <span class="nf">loaded</span><span class="p">([</span><span class="kt">Post</span><span class="p">])</span>
        <span class="k">case</span> <span class="nf">failed</span><span class="p">(</span><span class="kt">Error</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">enum</span> <span class="kt">ViewModelType</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">loading</span>
        <span class="k">case</span> <span class="nf">post</span><span class="p">(</span><span class="kt">PostViewModel</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">empty</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">error</span><span class="p">(</span><span class="kt">ErrorViewModel</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">let</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">State</span>
    
    <span class="k">let</span> <span class="nv">viewModels</span><span class="p">:</span> <span class="p">[</span><span class="kt">ViewModelType</span><span class="p">]</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Both <code class="language-plaintext highlighter-rouge">ProfileViewModel</code> and <code class="language-plaintext highlighter-rouge">PostsViewModel</code> are responsible for transforming their input <code class="language-plaintext highlighter-rouge">State</code> into a list of <code class="language-plaintext highlighter-rouge">viewModels</code> corresponding 1-to-1 with cells.</p>

<p>And finally we can compose these two view models into <code class="language-plaintext highlighter-rouge">UserViewModel</code>.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// V2 - screen-level view model</span>
<span class="kd">struct</span> <span class="kt">UserViewModel</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">ViewModelType</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">profileHeader</span><span class="p">(</span><span class="kt">ProfileHeaderViewModel</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">profileError</span><span class="p">(</span><span class="kt">ErrorViewModel</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">profileAttribute</span><span class="p">(</span><span class="kt">ProfileAttributeViewModel</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">contentHeader</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span> <span class="c1">// "Posts"</span>
        <span class="k">case</span> <span class="n">contentLoading</span>
        <span class="k">case</span> <span class="nf">contentEmpty</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">contentError</span><span class="p">(</span><span class="kt">ErrorViewModel</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">post</span><span class="p">(</span><span class="kt">PostViewModel</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// Inputs</span>
    <span class="k">let</span> <span class="nv">profileViewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span>
    <span class="k">let</span> <span class="nv">postsViewModel</span><span class="p">:</span> <span class="kt">PostsViewModel</span>
    
    <span class="c1">// Output</span>
    <span class="k">let</span> <span class="nv">viewModels</span><span class="p">:</span> <span class="p">[</span><span class="kt">ViewModelType</span><span class="p">]</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">profileViewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span><span class="p">,</span> <span class="nv">postsViewModel</span><span class="p">:</span> <span class="kt">PostsViewModel</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">profileViewModel</span> <span class="o">=</span> <span class="n">profileViewModel</span>
        <span class="k">self</span><span class="o">.</span><span class="n">postsViewModel</span> <span class="o">=</span> <span class="n">postsViewModel</span>
        
        <span class="k">let</span> <span class="nv">profileViewModels</span> <span class="o">=</span> <span class="n">profileViewModel</span><span class="o">.</span><span class="n">viewModels</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">UserViewModel</span><span class="o">.</span><span class="n">toViewModel</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">postsHeaderViewModels</span> <span class="o">=</span> <span class="p">[</span><span class="kt">ViewModelType</span><span class="o">.</span><span class="nf">contentHeader</span><span class="p">(</span><span class="s">"Posts"</span><span class="p">)]</span>
        <span class="k">let</span> <span class="nv">postsViewModels</span> <span class="o">=</span> <span class="n">postsViewModel</span><span class="o">.</span><span class="n">viewModels</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">UserViewModel</span><span class="o">.</span><span class="n">toViewModel</span><span class="p">)</span>
        
        <span class="k">let</span> <span class="nv">innerViewModels</span><span class="p">:</span> <span class="p">[</span><span class="kt">ViewModelType</span><span class="p">]</span> <span class="o">=</span> <span class="n">profileViewModels</span> <span class="o">+</span> <span class="n">postsHeaderViewModels</span> <span class="o">+</span> <span class="n">postsViewModels</span>
        
        <span class="k">self</span><span class="o">.</span><span class="n">viewModels</span> <span class="o">=</span> <span class="n">innerViewModels</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">toViewModel</span><span class="p">(</span><span class="n">_</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ProfileViewModel</span><span class="o">.</span><span class="kt">ViewModelType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UserViewModel</span><span class="o">.</span><span class="kt">ViewModelType</span> <span class="p">{</span>
        <span class="cm">/* ... */</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">toViewModel</span><span class="p">(</span><span class="n">_</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">PostsViewModel</span><span class="o">.</span><span class="kt">ViewModelType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UserViewModel</span><span class="o">.</span><span class="kt">ViewModelType</span> <span class="p">{</span>
        <span class="cm">/* ... */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="language-plaintext highlighter-rouge">UserViewModel</code> only needs to map the inner view model types to its own enum <code class="language-plaintext highlighter-rouge">UserViewModel.ViewModelType</code> and concatenate the results into one array. <code class="language-plaintext highlighter-rouge">UserViewModel</code> has no state of its own. It composes the contents of its view models and exposes its own set of view models to the view layer.</p>

<p>The view layer will only need to access <code class="language-plaintext highlighter-rouge">viewModels</code>.</p>

<p>We now have the option of using <code class="language-plaintext highlighter-rouge">ProfileViewModel</code> and <code class="language-plaintext highlighter-rouge">PostsViewModel</code> alone on other screens, or composing them with other view models into other combinations.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Modeling view model state is only a small part of designing a robust screen. Iâ€™ve elided a lot of the implementation details in this post in order to keep it more concise. Iâ€™ll explore the integration of these view models into the rest of the system in subsequent posts.</p>

<p>Note that Iâ€™ve also elided <code class="language-plaintext highlighter-rouge">Equatable</code> implementations for each of these structs. <code class="language-plaintext highlighter-rouge">Equatable</code> conformance is important in doing diffing on the view side since our entire screens view model will change on every update to the composed view models.</p>

<p>It should now be easier to understand the pros this technique:</p>

<ul>
  <li>The view controller is now mostly glue code, setting view models on subviews.</li>
  <li>Comparing view states when testing (with <code class="language-plaintext highlighter-rouge">Equatable</code> implemented) is as simple as <code class="language-plaintext highlighter-rouge">XCTAssertEqual(viewModel, expectedViewModel)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">PostsViewModel</code>â€™s logic can be used on other screens. Thereâ€™s even some breathing room for using different view designs with the same data.</li>
  <li>Using explicit enumerable input states for our higher-level view models ensures that no bad view states can occur.</li>
  <li>Once view states are explicitly defined, itâ€™s trivial to pass off the work of creating a view layer to another engineer.</li>
</ul>

<p>And the cons:</p>

<ul>
  <li>Lots more code to write and maintain, especially when considering manually writing <code class="language-plaintext highlighter-rouge">Equatable</code>.</li>
  <li>Some background knowledge about how to implement the view hierarchy in <code class="language-plaintext highlighter-rouge">UIKit</code> needs to be known ahead of time in order to correctly design the view models on the first try.</li>
</ul>

<p>I consider the overhead to be worthwhile if your objective is robust code, the design is relatively stable, and testing is part of your culture. Conversely, it might not be worthwhile if your product design is undergoing rapid change, secondary view states are not important to product validation, and a certain quantity of bugs are acceptable.</p>

<p>Other recommended reading on this topic: <a href="https://www.swiftbysundell.com/posts/modelling-state-in-swift">Modelling state in Swift</a>.</p>

<p>Thanks for reading, and please let me know your thoughts and suggestions. Iâ€™m <a href="https://twitter.com/twocentstudios">@twocentstudios</a> on Twitter.</p>

<blockquote>
  <p>Thanks to Evan Coleman and Ernesto Carrion for reading drafts of this post.</p>
</blockquote>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">twocentstudios</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:chris@twocentstudios.com">chris@twocentstudios.com</a></li>
          
          <li>
            <a href="https://github.com/twocentstudios">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/twocentstudios">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">twocentstudios</span>
            </a>
          </li>
          
        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
